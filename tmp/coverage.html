
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bencode: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">tgragnato.it/magnetico/v2/bencode/api.go (53.1%)</option>
				
				<option value="file1">tgragnato.it/magnetico/v2/bencode/bytes.go (100.0%)</option>
				
				<option value="file2">tgragnato.it/magnetico/v2/bencode/decode.go (75.3%)</option>
				
				<option value="file3">tgragnato.it/magnetico/v2/bencode/encode.go (80.3%)</option>
				
				<option value="file4">tgragnato.it/magnetico/v2/bencode/scanner.go (61.1%)</option>
				
				<option value="file5">tgragnato.it/magnetico/v2/bencode/tags.go (91.7%)</option>
				
				<option value="file6">tgragnato.it/magnetico/v2/dht/mainline/codec.go (85.6%)</option>
				
				<option value="file7">tgragnato.it/magnetico/v2/dht/mainline/indexingService.go (71.8%)</option>
				
				<option value="file8">tgragnato.it/magnetico/v2/dht/mainline/protocol.go (84.2%)</option>
				
				<option value="file9">tgragnato.it/magnetico/v2/dht/mainline/routingTable.go (88.9%)</option>
				
				<option value="file10">tgragnato.it/magnetico/v2/dht/mainline/transport.go (78.3%)</option>
				
				<option value="file11">tgragnato.it/magnetico/v2/dht/managers.go (58.8%)</option>
				
				<option value="file12">tgragnato.it/magnetico/v2/main.go (0.0%)</option>
				
				<option value="file13">tgragnato.it/magnetico/v2/merkle/hash.go (88.2%)</option>
				
				<option value="file14">tgragnato.it/magnetico/v2/merkle/merkle.go (85.2%)</option>
				
				<option value="file15">tgragnato.it/magnetico/v2/metadata/btconn/accept.go (66.7%)</option>
				
				<option value="file16">tgragnato.it/magnetico/v2/metadata/btconn/conn.go (100.0%)</option>
				
				<option value="file17">tgragnato.it/magnetico/v2/metadata/btconn/dial.go (75.0%)</option>
				
				<option value="file18">tgragnato.it/magnetico/v2/metadata/btconn/handshake.go (86.7%)</option>
				
				<option value="file19">tgragnato.it/magnetico/v2/metadata/btconn/mse.go (72.0%)</option>
				
				<option value="file20">tgragnato.it/magnetico/v2/metadata/infoHashes.go (92.7%)</option>
				
				<option value="file21">tgragnato.it/magnetico/v2/metadata/leech.go (57.6%)</option>
				
				<option value="file22">tgragnato.it/magnetico/v2/metadata/sink.go (83.3%)</option>
				
				<option value="file23">tgragnato.it/magnetico/v2/metadata/util.go (90.5%)</option>
				
				<option value="file24">tgragnato.it/magnetico/v2/metainfo/announcelist.go (84.6%)</option>
				
				<option value="file25">tgragnato.it/magnetico/v2/metainfo/bep52.go (78.3%)</option>
				
				<option value="file26">tgragnato.it/magnetico/v2/metainfo/file-tree.go (77.6%)</option>
				
				<option value="file27">tgragnato.it/magnetico/v2/metainfo/fileinfo.go (50.0%)</option>
				
				<option value="file28">tgragnato.it/magnetico/v2/metainfo/info.go (77.2%)</option>
				
				<option value="file29">tgragnato.it/magnetico/v2/metainfo/magnet-v2.go (70.6%)</option>
				
				<option value="file30">tgragnato.it/magnetico/v2/metainfo/magnet.go (89.1%)</option>
				
				<option value="file31">tgragnato.it/magnetico/v2/metainfo/metainfo.go (56.2%)</option>
				
				<option value="file32">tgragnato.it/magnetico/v2/metainfo/nodes.go (85.7%)</option>
				
				<option value="file33">tgragnato.it/magnetico/v2/metainfo/piece-length.go (100.0%)</option>
				
				<option value="file34">tgragnato.it/magnetico/v2/metainfo/piece.go (27.0%)</option>
				
				<option value="file35">tgragnato.it/magnetico/v2/metainfo/pieces.go (88.9%)</option>
				
				<option value="file36">tgragnato.it/magnetico/v2/metainfo/urllist.go (90.9%)</option>
				
				<option value="file37">tgragnato.it/magnetico/v2/opflags/load_cred.go (84.2%)</option>
				
				<option value="file38">tgragnato.it/magnetico/v2/opflags/opflags.go (85.7%)</option>
				
				<option value="file39">tgragnato.it/magnetico/v2/opflags/parsers.go (37.5%)</option>
				
				<option value="file40">tgragnato.it/magnetico/v2/stats/metrics.go (100.0%)</option>
				
				<option value="file41">tgragnato.it/magnetico/v2/stats/pyroscope.go (100.0%)</option>
				
				<option value="file42">tgragnato.it/magnetico/v2/stats/stats.go (100.0%)</option>
				
				<option value="file43">tgragnato.it/magnetico/v2/types/infohash-v2/infohash-v2.go (80.6%)</option>
				
				<option value="file44">tgragnato.it/magnetico/v2/types/infohash/infohash.go (83.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package bencode

import (
        "bytes"
        "fmt"
        "io"
        "reflect"
)

//----------------------------------------------------------------------------
// Errors
//----------------------------------------------------------------------------

// In case if marshaler cannot encode a type, it will return this error. Typical
// example of such type is float32/float64 which has no bencode representation.
type MarshalTypeError struct {
        Type reflect.Type
}

func (e *MarshalTypeError) Error() string <span class="cov0" title="0">{
        return "bencode: unsupported type: " + e.Type.String()
}</span>

// Unmarshal argument must be a non-nil value of some pointer type.
type UnmarshalInvalidArgError struct {
        Type reflect.Type
}

func (e *UnmarshalInvalidArgError) Error() string <span class="cov0" title="0">{
        if e.Type == nil </span><span class="cov0" title="0">{
                return "bencode: Unmarshal(nil)"
        }</span>

        <span class="cov0" title="0">if e.Type.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                return "bencode: Unmarshal(non-pointer " + e.Type.String() + ")"
        }</span>
        <span class="cov0" title="0">return "bencode: Unmarshal(nil " + e.Type.String() + ")"</span>
}

// Unmarshaler spotted a value that was not appropriate for a given Go value.
type UnmarshalTypeError struct {
        BencodeTypeName     string
        UnmarshalTargetType reflect.Type
}

// This could probably be a value type, but we may already have users assuming
// that it's passed by pointer.
func (e *UnmarshalTypeError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "can't unmarshal a bencode %v into a %v",
                e.BencodeTypeName,
                e.UnmarshalTargetType,
        )
}</span>

// Unmarshaler tried to write to an unexported (therefore unwritable) field.
type UnmarshalFieldError struct {
        Key   string
        Type  reflect.Type
        Field reflect.StructField
}

func (e *UnmarshalFieldError) Error() string <span class="cov0" title="0">{
        return "bencode: key \"" + e.Key + "\" led to an unexported field \"" +
                e.Field.Name + "\" in type: " + e.Type.String()
}</span>

// Malformed bencode input, unmarshaler failed to parse it.
type SyntaxError struct {
        Offset int64 // location of the error
        What   error // error description
}

func (e *SyntaxError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("bencode: syntax error (offset: %d): %s", e.Offset, e.What)
}</span>

// A non-nil error was returned after calling MarshalBencode on a type which
// implements the Marshaler interface.
type MarshalerError struct {
        Type reflect.Type
        Err  error
}

func (e *MarshalerError) Error() string <span class="cov0" title="0">{
        return "bencode: error calling MarshalBencode for type " + e.Type.String() + ": " + e.Err.Error()
}</span>

// A non-nil error was returned after calling UnmarshalBencode on a type which
// implements the Unmarshaler interface.
type UnmarshalerError struct {
        Type reflect.Type
        Err  error
}

func (e *UnmarshalerError) Error() string <span class="cov0" title="0">{
        return "bencode: error calling UnmarshalBencode for type " + e.Type.String() + ": " + e.Err.Error()
}</span>

//----------------------------------------------------------------------------
// Interfaces
//----------------------------------------------------------------------------

// Any type which implements this interface, will be marshaled using the
// specified method.
type Marshaler interface {
        MarshalBencode() ([]byte, error)
}

// Any type which implements this interface, will be unmarshaled using the
// specified method.
type Unmarshaler interface {
        UnmarshalBencode([]byte) error
}

// Marshal the value 'v' to the bencode form, return the result as []byte and
// an error if any.
func Marshal(v interface{}) ([]byte, error) <span class="cov8" title="1">{
        var buf bytes.Buffer
        e := Encoder{w: &amp;buf}
        err := e.Encode(v)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

func MustMarshal(v interface{}) []byte <span class="cov0" title="0">{
        b, err := Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return b</span>
}

// Unmarshal the bencode value in the 'data' to a value pointed by the 'v' pointer, return a non-nil
// error if any. If there are trailing bytes, this results in ErrUnusedTrailingBytes, but the value
// will be valid. It's probably more consistent to use Decoder.Decode if you want to rely on this
// behaviour (inspired by Rust's serde here).
func Unmarshal(data []byte, v interface{}) (err error) <span class="cov8" title="1">{
        buf := bytes.NewReader(data)
        dec := Decoder{r: buf}
        err = dec.Decode(v)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if buf.Len() != 0 </span><span class="cov8" title="1">{
                return ErrUnusedTrailingBytes{buf.Len()}
        }</span>
        <span class="cov8" title="1">return dec.ReadEOF()</span>
}

type ErrUnusedTrailingBytes struct {
        NumUnusedBytes int
}

func (me ErrUnusedTrailingBytes) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%d unused trailing bytes", me.NumUnusedBytes)
}</span>

func NewDecoder(r io.Reader) *Decoder <span class="cov8" title="1">{
        return &amp;Decoder{r: &amp;scanner{r: r}}
}</span>

func NewEncoder(w io.Writer) *Encoder <span class="cov0" title="0">{
        return &amp;Encoder{w: w}
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package bencode

import (
        "errors"
        "fmt"
)

type Bytes []byte

var (
        _ Unmarshaler = (*Bytes)(nil)
        _ Marshaler   = (*Bytes)(nil)
        _ Marshaler   = Bytes{}
)

// Unmarshals the provided byte slice into the Bytes receiver.
func (me *Bytes) UnmarshalBencode(b []byte) error <span class="cov8" title="1">{
        *me = append([]byte(nil), b...)
        return nil
}</span>

// Marshals the Bytes receiver into a byte slice.
func (me Bytes) MarshalBencode() ([]byte, error) <span class="cov8" title="1">{
        if len(me) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("marshalled Bytes should not be zero-length")
        }</span>
        <span class="cov8" title="1">return me, nil</span>
}

// Returns a Go-syntax string representation of the Bytes receiver.
func (me Bytes) GoString() string <span class="cov8" title="1">{
        return fmt.Sprintf("bencode.Bytes(%q)", []byte(me))
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package bencode

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "math/big"
        "reflect"
        "runtime"
        "strconv"
        "sync"
)

// The default bencode string length limit. This is a poor attempt to prevent excessive memory
// allocation when parsing, but also leaves the window open to implement a better solution.
const DefaultDecodeMaxStrLen = 1&lt;&lt;27 - 1 // ~128MiB

type MaxStrLen = int64

type Decoder struct {
        // Maximum parsed bencode string length. Defaults to DefaultMaxStrLen if zero.
        MaxStrLen MaxStrLen

        r interface {
                io.ByteScanner
                io.Reader
        }
        // Sum of bytes used to Decode values.
        Offset int64
        buf    bytes.Buffer
}

// NewDecoder returns a new decoder that reads from r.
func (d *Decoder) Decode(v interface{}) (err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">r := recover()
                if r == nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">_, ok := r.(runtime.Error)
                if ok </span><span class="cov0" title="0">{
                        panic(r)</span>
                }
                <span class="cov8" title="1">if err, ok = r.(error); !ok </span><span class="cov0" title="0">{
                        panic(r)</span>
                }
                // Errors thrown from deeper in parsing are unexpected. At value boundaries, errors should
                // be returned directly (at least until all the panic nonsense is removed entirely).
                <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                        err = io.ErrUnexpectedEOF
                }</span>
        }()

        <span class="cov8" title="1">pv := reflect.ValueOf(v)
        if pv.Kind() != reflect.Ptr || pv.IsNil() </span><span class="cov0" title="0">{
                return &amp;UnmarshalInvalidArgError{reflect.TypeOf(v)}
        }</span>

        <span class="cov8" title="1">ok, err := d.parseValue(pv.Elem())
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                d.throwSyntaxError(d.Offset-1, errors.New("unexpected 'e'"))
        }</span>
        <span class="cov8" title="1">return</span>
}

// Check for EOF in the decoder input stream. Used to assert the input ends on a clean message
// boundary.
func (d *Decoder) ReadEOF() error <span class="cov8" title="1">{
        _, err := d.r.ReadByte()
        if err == nil </span><span class="cov0" title="0">{
                err := d.r.UnreadByte()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("expected EOF, got %w", err)</span>
}

func checkForUnexpectedEOF(err error, offset int64) <span class="cov0" title="0">{
        if err == io.EOF </span><span class="cov0" title="0">{
                panic(&amp;SyntaxError{
                        Offset: offset,
                        What:   io.ErrUnexpectedEOF,
                })</span>
        }
}

func (d *Decoder) readByte() byte <span class="cov8" title="1">{
        b, err := d.r.ReadByte()
        if err != nil </span><span class="cov0" title="0">{
                checkForUnexpectedEOF(err, d.Offset)
                panic(err)</span>
        }

        <span class="cov8" title="1">d.Offset++
        return b</span>
}

// reads data writing it to 'd.buf' until 'sep' byte is encountered, 'sep' byte
// is consumed, but not included into the 'd.buf'
func (d *Decoder) readUntil(sep byte) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                b := d.readByte()
                if b == sep </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">d.buf.WriteByte(b)</span>
        }
}

func checkForIntParseError(err error, offset int64) <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                panic(&amp;SyntaxError{
                        Offset: offset,
                        What:   err,
                })</span>
        }
}

func (d *Decoder) throwSyntaxError(offset int64, err error) <span class="cov8" title="1">{
        panic(&amp;SyntaxError{
                Offset: offset,
                What:   err,
        })</span>
}

// Assume the 'i' is already consumed. Read and validate the rest of an int into the buffer.
func (d *Decoder) readInt() error <span class="cov8" title="1">{
        // start := d.Offset - 1
        d.readUntil('e')
        return d.checkBufferedInt()
}</span>

// called when 'i' was consumed, for the integer type in v.
func (d *Decoder) parseInt(v reflect.Value) error <span class="cov8" title="1">{
        start := d.Offset - 1

        if err := d.readInt(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s := d.buf.String()

        switch v.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                n, err := strconv.ParseInt(s, 10, 64)
                checkForIntParseError(err, start)

                if v.OverflowInt(n) </span><span class="cov0" title="0">{
                        return &amp;UnmarshalTypeError{
                                BencodeTypeName:     "int",
                                UnmarshalTargetType: v.Type(),
                        }
                }</span>
                <span class="cov8" title="1">v.SetInt(n)</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                n, err := strconv.ParseUint(s, 10, 64)
                checkForIntParseError(err, start)

                if v.OverflowUint(n) </span><span class="cov0" title="0">{
                        return &amp;UnmarshalTypeError{
                                BencodeTypeName:     "int",
                                UnmarshalTargetType: v.Type(),
                        }
                }</span>
                <span class="cov0" title="0">v.SetUint(n)</span>
        case reflect.Bool:<span class="cov8" title="1">
                v.SetBool(s != "0")</span>
        default:<span class="cov0" title="0">
                return &amp;UnmarshalTypeError{
                        BencodeTypeName:     "int",
                        UnmarshalTargetType: v.Type(),
                }</span>
        }
        <span class="cov8" title="1">d.buf.Reset()
        return nil</span>
}

func (d *Decoder) checkBufferedInt() error <span class="cov8" title="1">{
        b := d.buf.Bytes()
        if len(b) &lt;= 1 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if b[0] == '-' </span><span class="cov8" title="1">{
                b = b[1:]
        }</span>
        <span class="cov8" title="1">if b[0] &lt; '1' || b[0] &gt; '9' </span><span class="cov0" title="0">{
                return errors.New("invalid leading digit")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (d *Decoder) parseStringLength() (int, error) <span class="cov8" title="1">{
        // We should have already consumed the first byte of the length into the Decoder buf.
        start := d.Offset - 1
        d.readUntil(':')
        if err := d.checkBufferedInt(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        // Really the limit should be the uint size for the platform. But we can't pass in an allocator,
        // or limit total memory use in Go, the best we might hope to do is limit the size of a single
        // decoded value (by reading it in in-place and then operating on a view).
        <span class="cov8" title="1">length, err := strconv.ParseInt(d.buf.String(), 10, 0)
        checkForIntParseError(err, start)
        if int64(length) &gt; d.getMaxStrLen() </span><span class="cov8" title="1">{
                err = fmt.Errorf("parsed string length %v exceeds limit (%v)", length, DefaultDecodeMaxStrLen)
        }</span>
        <span class="cov8" title="1">d.buf.Reset()
        return int(length), err</span>
}

func (d *Decoder) parseString(v reflect.Value) error <span class="cov8" title="1">{
        length, err := d.parseStringLength()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer d.buf.Reset()
        read := func(b []byte) </span><span class="cov8" title="1">{
                n, err := io.ReadFull(d.r, b)
                d.Offset += int64(n)
                if err != nil </span><span class="cov0" title="0">{
                        checkForUnexpectedEOF(err, d.Offset)
                        panic(&amp;SyntaxError{
                                Offset: d.Offset,
                                What:   errors.New("unexpected I/O error: " + err.Error()),
                        })</span>
                }
        }

        <span class="cov8" title="1">switch v.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                b := make([]byte, length)
                read(b)
                v.SetString(string(b))
                return nil</span>
        case reflect.Slice:<span class="cov8" title="1">
                if v.Type().Elem().Kind() != reflect.Uint8 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">b := make([]byte, length)
                read(b)
                v.SetBytes(b)
                return nil</span>
        case reflect.Array:<span class="cov8" title="1">
                if v.Type().Elem().Kind() != reflect.Uint8 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">d.buf.Grow(length)
                b := d.buf.Bytes()[:length]
                read(b)
                reflect.Copy(v, reflect.ValueOf(b))
                return nil</span>
        case reflect.Bool:<span class="cov8" title="1">
                d.buf.Grow(length)
                b := d.buf.Bytes()[:length]
                read(b)
                x, err := strconv.ParseBool(string(b))
                if err != nil </span><span class="cov8" title="1">{
                        x = length != 0
                }</span>
                <span class="cov8" title="1">v.SetBool(x)
                return nil</span>
        }
        // Can't move this into default clause because some cases above fail through to here after
        // additional checks.
        <span class="cov8" title="1">d.buf.Grow(length)
        read(d.buf.Bytes()[:length])
        // I believe we return here to support "ignore_unmarshal_type_error".
        return &amp;UnmarshalTypeError{
                BencodeTypeName:     "string",
                UnmarshalTargetType: v.Type(),
        }</span>
}

// Info for parsing a dict value.
type dictField struct {
        Type reflect.Type
        Get  func(value reflect.Value) func(reflect.Value)
        Tags tag
}

// Returns specifics for parsing a dict field value.
func getDictField(dict reflect.Type, key reflect.Value) (_ dictField, err error) <span class="cov8" title="1">{
        // get valuev as a map value or as a struct field
        switch k := dict.Kind(); k </span>{
        case reflect.Map:<span class="cov8" title="1">
                return dictField{
                        Type: dict.Elem(),
                        Get: func(mapValue reflect.Value) func(reflect.Value) </span><span class="cov8" title="1">{
                                return func(value reflect.Value) </span><span class="cov8" title="1">{
                                        if mapValue.IsNil() </span><span class="cov8" title="1">{
                                                mapValue.Set(reflect.MakeMap(dict))
                                        }</span>
                                        // Assigns the value into the map.
                                        <span class="cov8" title="1">mapValue.SetMapIndex(key, value)</span>
                                }
                        },
                }, nil
        case reflect.Struct:<span class="cov8" title="1">
                if key.Kind() != reflect.String </span><span class="cov0" title="0">{
                        // This doesn't make sense for structs. They have to use strings. If they didn't they
                        // should at least have things that convert to strings trivially and somehow much the
                        // bencode tag.
                        panic(key)</span>
                }
                <span class="cov8" title="1">return getStructFieldForKey(dict, key.String()), nil</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("can't assign bencode dict items into a %v", k)
                return</span>
        }
}

var (
        structFieldsMu sync.Mutex
        structFields   = map[reflect.Type]map[string]dictField{}
)

func parseStructFields(struct_ reflect.Type, each func(key string, df dictField)) <span class="cov8" title="1">{
        for _i, n := 0, struct_.NumField(); _i &lt; n; _i++ </span><span class="cov8" title="1">{
                i := _i
                f := struct_.Field(i)
                if f.Anonymous </span><span class="cov0" title="0">{
                        t := f.Type
                        if t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                                t = t.Elem()
                        }</span>
                        <span class="cov0" title="0">parseStructFields(t, func(key string, df dictField) </span><span class="cov0" title="0">{
                                innerGet := df.Get
                                df.Get = func(value reflect.Value) func(reflect.Value) </span><span class="cov0" title="0">{
                                        anonPtr := value.Field(i)
                                        if anonPtr.Kind() == reflect.Ptr &amp;&amp; anonPtr.IsNil() </span><span class="cov0" title="0">{
                                                anonPtr.Set(reflect.New(f.Type.Elem()))
                                                anonPtr = anonPtr.Elem()
                                        }</span>
                                        <span class="cov0" title="0">return innerGet(anonPtr)</span>
                                }
                                <span class="cov0" title="0">each(key, df)</span>
                        })
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov8" title="1">tagStr := f.Tag.Get("bencode")
                if tagStr == "-" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">tag := parseTag(tagStr)
                key := tag.Key()
                if key == "" </span><span class="cov8" title="1">{
                        key = f.Name
                }</span>
                <span class="cov8" title="1">each(key, dictField{f.Type, func(value reflect.Value) func(reflect.Value) </span><span class="cov8" title="1">{
                        return value.Field(i).Set
                }</span>, tag})
        }
}

func saveStructFields(struct_ reflect.Type) <span class="cov8" title="1">{
        m := make(map[string]dictField)
        parseStructFields(struct_, func(key string, sf dictField) </span><span class="cov8" title="1">{
                m[key] = sf
        }</span>)
        <span class="cov8" title="1">structFields[struct_] = m</span>
}

func getStructFieldForKey(struct_ reflect.Type, key string) (f dictField) <span class="cov8" title="1">{
        structFieldsMu.Lock()
        if _, ok := structFields[struct_]; !ok </span><span class="cov8" title="1">{
                saveStructFields(struct_)
        }</span>
        <span class="cov8" title="1">f, ok := structFields[struct_][key]
        structFieldsMu.Unlock()
        if !ok </span><span class="cov0" title="0">{
                var discard interface{}
                return dictField{
                        Type: reflect.TypeOf(discard),
                        Get:  func(reflect.Value) func(reflect.Value) </span><span class="cov0" title="0">{ return func(reflect.Value) </span>{<span class="cov0" title="0">}</span> },
                        Tags: nil,
                }
        }
        <span class="cov8" title="1">return</span>
}

var structKeyType = reflect.TypeFor[string]()

func keyType(v reflect.Value) reflect.Type <span class="cov8" title="1">{
        switch v.Kind() </span>{
        case reflect.Map:<span class="cov8" title="1">
                return v.Type().Key()</span>
        case reflect.Struct:<span class="cov8" title="1">
                return structKeyType</span>
        default:<span class="cov8" title="1">
                return nil</span>
        }
}

func (d *Decoder) parseDict(v reflect.Value) error <span class="cov8" title="1">{
        // At this point 'd' byte was consumed, now read key/value pairs.

        // The key type does not need to be a string for maps.
        keyType := keyType(v)
        if keyType == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot parse dicts into %v", v.Type())
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                keyValue := reflect.New(keyType).Elem()
                ok, err := d.parseValue(keyValue)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error parsing dict key: %w", err)
                }</span>
                <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">df, err := getDictField(v.Type(), keyValue)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("parsing bencode dict into %v: %w", v.Type(), err)
                }</span>

                // now we need to actually parse it
                <span class="cov8" title="1">if df.Type == nil </span><span class="cov0" title="0">{
                        // Discard the value, there's nowhere to put it.
                        var if_ interface{}
                        if_, ok = d.parseValueInterface()
                        if if_ == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error parsing value for key %q", keyValue)
                        }</span>
                        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("missing value for key %q", keyValue)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov8" title="1">setValue := reflect.New(df.Type).Elem()
                ok, err = d.parseValue(setValue)
                if err != nil </span><span class="cov8" title="1">{
                        var target *UnmarshalTypeError
                        if !errors.As(err, &amp;target) || !df.Tags.IgnoreUnmarshalTypeError() </span><span class="cov8" title="1">{
                                return fmt.Errorf("parsing value for key %q: %w", keyValue, err)
                        }</span>
                }
                <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing value for key %q", keyValue)
                }</span>
                <span class="cov8" title="1">df.Get(v)(setValue)</span>
        }
}

func (d *Decoder) parseList(v reflect.Value) error <span class="cov8" title="1">{
        switch v.Kind() </span>{
        default:<span class="cov0" title="0">
                // If the list is a singleton of the expected type, use that value.
                l := reflect.New(reflect.SliceOf(v.Type()))
                if err := d.parseList(l.Elem()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if l.Elem().Len() != 1 </span><span class="cov0" title="0">{
                        return &amp;UnmarshalTypeError{
                                BencodeTypeName:     "list",
                                UnmarshalTargetType: v.Type(),
                        }
                }</span>
                <span class="cov0" title="0">v.Set(l.Elem().Index(0))
                return nil</span>
        case reflect.Array, reflect.Slice:<span class="cov8" title="1"></span>
                // We can work with this. Normal case, fallthrough.
        }

        <span class="cov8" title="1">i := 0
        for ; ; i++ </span><span class="cov8" title="1">{
                if v.Kind() == reflect.Slice &amp;&amp; i &gt;= v.Len() </span><span class="cov8" title="1">{
                        v.Set(reflect.Append(v, reflect.Zero(v.Type().Elem())))
                }</span>

                <span class="cov8" title="1">if i &lt; v.Len() </span><span class="cov8" title="1">{
                        ok, err := d.parseValue(v.Index(i))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                                break</span>
                        }
                } else<span class="cov0" title="0"> {
                        _, ok := d.parseValueInterface()
                        if !ok </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if i &lt; v.Len() </span><span class="cov8" title="1">{
                if v.Kind() == reflect.Array </span><span class="cov0" title="0">{
                        z := reflect.Zero(v.Type().Elem())
                        for n := v.Len(); i &lt; n; i++ </span><span class="cov0" title="0">{
                                v.Index(i).Set(z)
                        }</span>
                } else<span class="cov8" title="1"> {
                        v.SetLen(i)
                }</span>
        }

        <span class="cov8" title="1">if i == 0 &amp;&amp; v.Kind() == reflect.Slice </span><span class="cov0" title="0">{
                v.Set(reflect.MakeSlice(v.Type(), 0, 0))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (d *Decoder) readOneValue() bool <span class="cov8" title="1">{
        b, err := d.r.ReadByte()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">if b == 'e' </span><span class="cov8" title="1">{
                if err := d.r.UnreadByte(); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov8" title="1">return false</span>
        } else<span class="cov8" title="1"> {
                d.Offset++
                d.buf.WriteByte(b)
        }</span>

        <span class="cov8" title="1">switch b </span>{
        case 'd', 'l':<span class="cov0" title="0">
                // read until there is nothing to read
                for d.readOneValue() </span>{<span class="cov0" title="0">
                }</span>
                // consume 'e' as well
                <span class="cov0" title="0">b = d.readByte()
                d.buf.WriteByte(b)</span>
        case 'i':<span class="cov8" title="1">
                d.readUntil('e')
                d.buf.WriteString("e")</span>
        default:<span class="cov8" title="1">
                if b &gt;= '0' &amp;&amp; b &lt;= '9' </span><span class="cov8" title="1">{
                        start := d.buf.Len() - 1
                        d.readUntil(':')
                        length, err := strconv.ParseInt(d.buf.String()[start:], 10, 64)
                        checkForIntParseError(err, d.Offset-1)

                        d.buf.WriteString(":")
                        n, err := io.CopyN(&amp;d.buf, d.r, length)
                        d.Offset += n
                        if err != nil </span><span class="cov0" title="0">{
                                checkForUnexpectedEOF(err, d.Offset)
                                panic(&amp;SyntaxError{
                                        Offset: d.Offset,
                                        What:   errors.New("unexpected I/O error: " + err.Error()),
                                })</span>
                        }
                        <span class="cov8" title="1">break</span>
                }

                <span class="cov0" title="0">d.raiseUnknownValueType(b, d.Offset-1)</span>
        }

        <span class="cov8" title="1">return true</span>
}

func (d *Decoder) parseUnmarshaler(v reflect.Value) bool <span class="cov8" title="1">{
        if !v.Type().Implements(reflect.TypeOf((*Unmarshaler)(nil)).Elem()) </span><span class="cov8" title="1">{
                if v.Addr().Type().Implements(reflect.TypeOf((*Unmarshaler)(nil)).Elem()) </span><span class="cov8" title="1">{
                        v = v.Addr()
                }</span> else<span class="cov8" title="1"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">d.buf.Reset()
        if !d.readOneValue() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">m := v.Interface().(Unmarshaler)
        err := m.UnmarshalBencode(d.buf.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                panic(&amp;UnmarshalerError{v.Type(), err})</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Returns true if there was a value and it's now stored in 'v'. Otherwise, there was an end symbol
// ("e") and no value was stored.
func (d *Decoder) parseValue(v reflect.Value) (bool, error) <span class="cov8" title="1">{
        // we support one level of indirection at the moment
        if v.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                // if the pointer is nil, allocate a new element of the type it
                // points to
                if v.IsNil() </span><span class="cov8" title="1">{
                        v.Set(reflect.New(v.Type().Elem()))
                }</span>
                <span class="cov8" title="1">v = v.Elem()</span>
        }

        <span class="cov8" title="1">if d.parseUnmarshaler(v) </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        // common case: interface{}
        <span class="cov8" title="1">if v.Kind() == reflect.Interface &amp;&amp; v.NumMethod() == 0 </span><span class="cov8" title="1">{
                iface, _ := d.parseValueInterface()
                v.Set(reflect.ValueOf(iface))
                return true, nil
        }</span>

        <span class="cov8" title="1">b, err := d.r.ReadByte()
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">d.Offset++

        switch b </span>{
        case 'e':<span class="cov8" title="1">
                return false, nil</span>
        case 'd':<span class="cov8" title="1">
                return true, d.parseDict(v)</span>
        case 'l':<span class="cov8" title="1">
                return true, d.parseList(v)</span>
        case 'i':<span class="cov8" title="1">
                return true, d.parseInt(v)</span>
        default:<span class="cov8" title="1">
                if b &gt;= '0' &amp;&amp; b &lt;= '9' </span><span class="cov8" title="1">{
                        // It's a string.
                        d.buf.Reset()
                        // Write the first digit of the length to the buffer.
                        d.buf.WriteByte(b)
                        return true, d.parseString(v)
                }</span>

                <span class="cov0" title="0">d.raiseUnknownValueType(b, d.Offset-1)</span>
        }
        <span class="cov0" title="0">panic("unreachable")</span>
}

// An unknown bencode type character was encountered.
func (d *Decoder) raiseUnknownValueType(b byte, offset int64) <span class="cov0" title="0">{
        panic(&amp;SyntaxError{
                Offset: offset,
                What:   fmt.Errorf("unknown value type %+q", b),
        })</span>
}

func (d *Decoder) parseValueInterface() (interface{}, bool) <span class="cov8" title="1">{
        b, err := d.r.ReadByte()
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
        <span class="cov8" title="1">d.Offset++

        switch b </span>{
        case 'e':<span class="cov8" title="1">
                return nil, false</span>
        case 'd':<span class="cov8" title="1">
                return d.parseDictInterface(), true</span>
        case 'l':<span class="cov8" title="1">
                return d.parseListInterface(), true</span>
        case 'i':<span class="cov8" title="1">
                return d.parseIntInterface(), true</span>
        default:<span class="cov8" title="1">
                if b &gt;= '0' &amp;&amp; b &lt;= '9' </span><span class="cov8" title="1">{
                        // string
                        // append first digit of the length to the buffer
                        d.buf.WriteByte(b)
                        return d.parseStringInterface(), true
                }</span>

                <span class="cov0" title="0">d.raiseUnknownValueType(b, d.Offset-1)
                panic("unreachable")</span>
        }
}

// Called after 'i', for an arbitrary integer size.
func (d *Decoder) parseIntInterface() (ret interface{}) <span class="cov8" title="1">{
        start := d.Offset - 1

        if err := d.readInt(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">n, err := strconv.ParseInt(d.buf.String(), 10, 64)
        if ne, ok := err.(*strconv.NumError); ok &amp;&amp; ne.Err == strconv.ErrRange </span><span class="cov8" title="1">{
                i := new(big.Int)
                _, ok := i.SetString(d.buf.String(), 10)
                if !ok </span><span class="cov0" title="0">{
                        panic(&amp;SyntaxError{
                                Offset: start,
                                What:   errors.New("failed to parse integer"),
                        })</span>
                }
                <span class="cov8" title="1">ret = i</span>
        } else<span class="cov8" title="1"> {
                checkForIntParseError(err, start)
                ret = n
        }</span>

        <span class="cov8" title="1">d.buf.Reset()
        return</span>
}

func (d *Decoder) readBytes(length int) []byte <span class="cov8" title="1">{
        b, err := io.ReadAll(io.LimitReader(d.r, int64(length)))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">if len(b) != length </span><span class="cov0" title="0">{
                panic(fmt.Errorf("read %v bytes expected %v", len(b), length))</span>
        }
        <span class="cov8" title="1">return b</span>
}

func (d *Decoder) parseStringInterface() string <span class="cov8" title="1">{
        length, err := d.parseStringLength()
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
        <span class="cov8" title="1">b := d.readBytes(int(length))
        d.Offset += int64(len(b))
        return string(b)</span>
}

func (d *Decoder) parseDictInterface() interface{} <span class="cov8" title="1">{
        dict := make(map[string]interface{})
        var lastKey string
        lastKeyOk := false
        for </span><span class="cov8" title="1">{
                start := d.Offset
                keyi, ok := d.parseValueInterface()
                if !ok </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">key, ok := keyi.(string)
                if !ok </span><span class="cov0" title="0">{
                        panic(&amp;SyntaxError{
                                Offset: d.Offset,
                                What:   errors.New("non-string key in a dict"),
                        })</span>
                }
                <span class="cov8" title="1">if lastKeyOk &amp;&amp; key &lt;= lastKey </span><span class="cov0" title="0">{
                        d.throwSyntaxError(start, fmt.Errorf("dict keys unsorted: %q &lt;= %q", key, lastKey))
                }</span>
                <span class="cov8" title="1">start = d.Offset
                valuei, ok := d.parseValueInterface()
                if !ok </span><span class="cov0" title="0">{
                        d.throwSyntaxError(start, fmt.Errorf("dict elem missing value [key=%v]", key))
                }</span>

                <span class="cov8" title="1">lastKey = key
                lastKeyOk = true
                dict[key] = valuei</span>
        }
        <span class="cov8" title="1">return dict</span>
}

func (d *Decoder) parseListInterface() (list []interface{}) <span class="cov8" title="1">{
        list = []interface{}{}
        valuei, ok := d.parseValueInterface()
        for ok </span><span class="cov8" title="1">{
                list = append(list, valuei)
                valuei, ok = d.parseValueInterface()
        }</span>
        <span class="cov8" title="1">return</span>
}

func (d *Decoder) getMaxStrLen() int64 <span class="cov8" title="1">{
        if d.MaxStrLen == 0 </span><span class="cov8" title="1">{
                return DefaultDecodeMaxStrLen
        }</span>
        <span class="cov8" title="1">return d.MaxStrLen</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package bencode

import (
        "io"
        "math/big"
        "reflect"
        "runtime"
        "sort"
        "strconv"
        "sync"
)

func isEmptyValue(v reflect.Value) bool <span class="cov8" title="1">{
        switch v.Kind() </span>{
        case reflect.Func, reflect.Map, reflect.Slice:<span class="cov8" title="1">
                return v.IsNil()</span>
        case reflect.Array:<span class="cov8" title="1">
                z := true
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                        z = z &amp;&amp; isEmptyValue(v.Index(i))
                }</span>
                <span class="cov8" title="1">return z</span>
        case reflect.Struct:<span class="cov8" title="1">
                z := true
                for i := 0; i &lt; v.NumField(); i++ </span><span class="cov8" title="1">{
                        z = z &amp;&amp; isEmptyValue(v.Field(i))
                }</span>
                <span class="cov8" title="1">return z</span>
        default:<span class="cov8" title="1">
                if !v.IsValid() </span><span class="cov8" title="1">{
                        return true
                }</span>
                // Compare other types directly:
                <span class="cov8" title="1">z := reflect.Zero(v.Type())
                return v.Interface() == z.Interface()</span>
        }
}

type Encoder struct {
        w       io.Writer
        scratch [64]byte
}

func (e *Encoder) Encode(v interface{}) (err error) <span class="cov8" title="1">{
        if v == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if e := recover(); e != nil </span><span class="cov8" title="1">{
                        if _, ok := e.(runtime.Error); ok </span><span class="cov0" title="0">{
                                panic(e)</span>
                        }
                        <span class="cov8" title="1">var ok bool
                        err, ok = e.(error)
                        if !ok </span><span class="cov0" title="0">{
                                panic(e)</span>
                        }
                }
        }()
        <span class="cov8" title="1">e.reflectValue(reflect.ValueOf(v))
        return nil</span>
}

type stringValues []reflect.Value

func (sv stringValues) Len() int           <span class="cov8" title="1">{ return len(sv) }</span>
func (sv stringValues) Swap(i, j int)      <span class="cov8" title="1">{ sv[i], sv[j] = sv[j], sv[i] }</span>
func (sv stringValues) Less(i, j int) bool <span class="cov8" title="1">{ return sv.get(i) &lt; sv.get(j) }</span>
func (sv stringValues) get(i int) string   <span class="cov8" title="1">{ return sv[i].String() }</span>

func (e *Encoder) write(s []byte) <span class="cov8" title="1">{
        _, err := e.w.Write(s)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func (e *Encoder) writeString(s string) <span class="cov8" title="1">{
        for s != "" </span><span class="cov8" title="1">{
                n := copy(e.scratch[:], s)
                s = s[n:]
                e.write(e.scratch[:n])
        }</span>
}

func (e *Encoder) reflectString(s string) <span class="cov8" title="1">{
        e.writeStringPrefix(int64(len(s)))
        e.writeString(s)
}</span>

func (e *Encoder) writeStringPrefix(l int64) <span class="cov8" title="1">{
        b := strconv.AppendInt(e.scratch[:0], l, 10)
        e.write(b)
        e.writeString(":")
}</span>

func (e *Encoder) reflectByteSlice(s []byte) <span class="cov8" title="1">{
        e.writeStringPrefix(int64(len(s)))
        e.write(s)
}</span>

// Returns true if the value implements Marshaler interface and marshaling was
// done successfully.
func (e *Encoder) reflectMarshaler(v reflect.Value) bool <span class="cov8" title="1">{
        if !v.Type().Implements(reflect.TypeOf((*Marshaler)(nil)).Elem()) </span><span class="cov8" title="1">{
                if v.Kind() != reflect.Ptr &amp;&amp; v.CanAddr() &amp;&amp; v.Addr().Type().Implements(reflect.TypeOf((*Marshaler)(nil)).Elem()) </span><span class="cov0" title="0">{
                        v = v.Addr()
                }</span> else<span class="cov8" title="1"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">m := v.Interface().(Marshaler)
        data, err := m.MarshalBencode()
        if err != nil </span><span class="cov8" title="1">{
                panic(&amp;MarshalerError{v.Type(), err})</span>
        }
        <span class="cov8" title="1">e.write(data)
        return true</span>
}

var bigIntType = reflect.TypeOf((*big.Int)(nil)).Elem()

func (e *Encoder) reflectValue(v reflect.Value) <span class="cov8" title="1">{
        if e.reflectMarshaler(v) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if v.Type() == bigIntType </span><span class="cov8" title="1">{
                e.writeString("i")
                bi := v.Interface().(big.Int)
                e.writeString(bi.String())
                e.writeString("e")
                return
        }</span>

        <span class="cov8" title="1">switch v.Kind() </span>{
        case reflect.Bool:<span class="cov8" title="1">
                if v.Bool() </span><span class="cov8" title="1">{
                        e.writeString("i1e")
                }</span> else<span class="cov8" title="1"> {
                        e.writeString("i0e")
                }</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                e.writeString("i")
                b := strconv.AppendInt(e.scratch[:0], v.Int(), 10)
                e.write(b)
                e.writeString("e")</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                e.writeString("i")
                b := strconv.AppendUint(e.scratch[:0], v.Uint(), 10)
                e.write(b)
                e.writeString("e")</span>
        case reflect.String:<span class="cov8" title="1">
                e.reflectString(v.String())</span>
        case reflect.Struct:<span class="cov8" title="1">
                e.writeString("d")
                for _, ef := range getEncodeFields(v.Type()) </span><span class="cov8" title="1">{
                        fieldValue := ef.i(v)
                        if !fieldValue.IsValid() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if ef.omitEmpty &amp;&amp; isEmptyValue(fieldValue) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">e.reflectString(ef.tag)
                        e.reflectValue(fieldValue)</span>
                }
                <span class="cov8" title="1">e.writeString("e")</span>
        case reflect.Map:<span class="cov8" title="1">
                if v.Type().Key().Kind() != reflect.String </span><span class="cov0" title="0">{
                        panic(&amp;MarshalTypeError{v.Type()})</span>
                }
                <span class="cov8" title="1">if v.IsNil() </span><span class="cov0" title="0">{
                        e.writeString("de")
                        break</span>
                }
                <span class="cov8" title="1">e.writeString("d")
                sv := stringValues(v.MapKeys())
                sort.Sort(sv)
                for _, key := range sv </span><span class="cov8" title="1">{
                        e.reflectString(key.String())
                        e.reflectValue(v.MapIndex(key))
                }</span>
                <span class="cov8" title="1">e.writeString("e")</span>
        case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                e.reflectSequence(v)</span>
        case reflect.Interface:<span class="cov8" title="1">
                e.reflectValue(v.Elem())</span>
        case reflect.Ptr:<span class="cov8" title="1">
                if v.IsNil() </span><span class="cov8" title="1">{
                        v = reflect.Zero(v.Type().Elem())
                }</span> else<span class="cov8" title="1"> {
                        v = v.Elem()
                }</span>
                <span class="cov8" title="1">e.reflectValue(v)</span>
        default:<span class="cov0" title="0">
                panic(&amp;MarshalTypeError{v.Type()})</span>
        }
}

func (e *Encoder) reflectSequence(v reflect.Value) <span class="cov8" title="1">{
        // Use bencode string-type
        if v.Type().Elem().Kind() == reflect.Uint8 </span><span class="cov8" title="1">{
                if v.Kind() != reflect.Slice </span><span class="cov8" title="1">{
                        // Can't use []byte optimization
                        if !v.CanAddr() </span><span class="cov0" title="0">{
                                e.writeStringPrefix(int64(v.Len()))
                                for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                                        var b [1]byte
                                        b[0] = byte(v.Index(i).Uint())
                                        e.write(b[:])
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                        <span class="cov8" title="1">v = v.Slice(0, v.Len())</span>
                }
                <span class="cov8" title="1">s := v.Bytes()
                e.reflectByteSlice(s)
                return</span>
        }
        <span class="cov8" title="1">if v.IsNil() </span><span class="cov0" title="0">{
                e.writeString("le")
                return
        }</span>
        <span class="cov8" title="1">e.writeString("l")
        for i, n := 0, v.Len(); i &lt; n; i++ </span><span class="cov8" title="1">{
                e.reflectValue(v.Index(i))
        }</span>
        <span class="cov8" title="1">e.writeString("e")</span>
}

type encodeField struct {
        i         func(v reflect.Value) reflect.Value
        tag       string
        omitEmpty bool
}

type encodeFieldsSortType []encodeField

func (ef encodeFieldsSortType) Len() int           <span class="cov8" title="1">{ return len(ef) }</span>
func (ef encodeFieldsSortType) Swap(i, j int)      <span class="cov8" title="1">{ ef[i], ef[j] = ef[j], ef[i] }</span>
func (ef encodeFieldsSortType) Less(i, j int) bool <span class="cov8" title="1">{ return ef[i].tag &lt; ef[j].tag }</span>

var (
        typeCacheLock     sync.RWMutex
        encodeFieldsCache = make(map[reflect.Type][]encodeField)
)

func getEncodeFields(t reflect.Type) []encodeField <span class="cov8" title="1">{
        typeCacheLock.RLock()
        fs, ok := encodeFieldsCache[t]
        typeCacheLock.RUnlock()
        if ok </span><span class="cov8" title="1">{
                return fs
        }</span>
        <span class="cov8" title="1">fs = makeEncodeFields(t)
        typeCacheLock.Lock()
        defer typeCacheLock.Unlock()
        encodeFieldsCache[t] = fs
        return fs</span>
}

func makeEncodeFields(t reflect.Type) (fs []encodeField) <span class="cov8" title="1">{
        for _i, n := 0, t.NumField(); _i &lt; n; _i++ </span><span class="cov8" title="1">{
                i := _i
                f := t.Field(i)
                if f.PkgPath != "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if f.Anonymous </span><span class="cov0" title="0">{
                        t := f.Type
                        if t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                                t = t.Elem()
                        }</span>
                        <span class="cov0" title="0">anonEFs := makeEncodeFields(t)
                        for aefi := range anonEFs </span><span class="cov0" title="0">{
                                anonEF := anonEFs[aefi]
                                bottomField := anonEF
                                bottomField.i = func(v reflect.Value) reflect.Value </span><span class="cov0" title="0">{
                                        v = v.Field(i)
                                        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                                                if v.IsNil() </span><span class="cov0" title="0">{
                                                        // This will skip serializing this value.
                                                        return reflect.Value{}
                                                }</span>
                                                <span class="cov0" title="0">v = v.Elem()</span>
                                        }
                                        <span class="cov0" title="0">return anonEF.i(v)</span>
                                }
                                <span class="cov0" title="0">fs = append(fs, bottomField)</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov8" title="1">var ef encodeField
                ef.i = func(v reflect.Value) reflect.Value </span><span class="cov8" title="1">{
                        return v.Field(i)
                }</span>
                <span class="cov8" title="1">ef.tag = f.Name

                tv := getTag(f.Tag)
                if tv.Ignore() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if tv.Key() != "" </span><span class="cov8" title="1">{
                        ef.tag = tv.Key()
                }</span>
                <span class="cov8" title="1">ef.omitEmpty = tv.OmitEmpty()
                fs = append(fs, ef)</span>
        }
        <span class="cov8" title="1">fss := encodeFieldsSortType(fs)
        sort.Sort(fss)
        return fs</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package bencode

import (
        "errors"
        "io"
)

// Implements io.ByteScanner over io.Reader, for use in Decoder, to ensure
// that as little as the undecoded input Reader is consumed as possible.
type scanner struct {
        r      io.Reader
        b      [1]byte // Buffer for ReadByte
        unread bool    // True if b has been unread, and so should be returned next
}

func (me *scanner) Read(b []byte) (int, error) <span class="cov8" title="1">{
        return me.r.Read(b)
}</span>

func (me *scanner) ReadByte() (byte, error) <span class="cov8" title="1">{
        if me.unread </span><span class="cov0" title="0">{
                me.unread = false
                return me.b[0], nil
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                n, err := me.r.Read(me.b[:])
                switch n </span>{
                case 0:<span class="cov8" title="1">
                        // io.Reader.Read says to try again if there's no error and no bytes returned. We can't
                        // signal that the caller should do this method's interface.
                        if err != nil </span><span class="cov8" title="1">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">panic(err)</span>
                case 1:<span class="cov8" title="1">
                        // There's no way to signal that the byte is valid unless error is nil.
                        return me.b[0], nil</span>
                default:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                // I can't see why Read would return more bytes than expected, but the error should
                                // tell us why.
                                panic(err)</span>
                        }
                        <span class="cov0" title="0">panic(n)</span>
                }
        }
}

func (me *scanner) UnreadByte() error <span class="cov8" title="1">{
        if me.unread </span><span class="cov0" title="0">{
                return errors.New("byte already unread")
        }</span>
        <span class="cov8" title="1">me.unread = true
        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package bencode

import (
        "reflect"
        "strings"
)

func getTag(st reflect.StructTag) tag <span class="cov8" title="1">{
        return parseTag(st.Get("bencode"))
}</span>

type tag []string

func parseTag(tagStr string) tag <span class="cov8" title="1">{
        return strings.Split(tagStr, ",")
}</span>

func (me tag) Ignore() bool <span class="cov8" title="1">{
        return me[0] == "-"
}</span>

func (me tag) Key() string <span class="cov8" title="1">{
        return me[0]
}</span>

func (me tag) HasOpt(opt string) bool <span class="cov8" title="1">{
        if len(me) &lt; 1 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for _, s := range me[1:] </span><span class="cov8" title="1">{
                if s == opt </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (me tag) OmitEmpty() bool <span class="cov8" title="1">{
        return me.HasOpt("omitempty")
}</span>

func (me tag) IgnoreUnmarshalTypeError() bool <span class="cov8" title="1">{
        return me.HasOpt("ignore_unmarshal_type_error")
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package mainline

import (
        "encoding/binary"
        "errors"
        "fmt"
        "net"
        "regexp"

        "github.com/bits-and-blooms/bloom/v3"
        "tgragnato.it/magnetico/v2/bencode"
)

type Message struct {
        // Query method. One of 5:
        //   - "ping"
        //   - "find_node"
        //   - "get_peers"
        //   - "announce_peer"
        //   - "sample_infohashes" (added by BEP 51)
        Q string `bencode:"q,omitempty"`
        // named QueryArguments sent with a query
        A QueryArguments `bencode:"a,omitempty"`
        // required: transaction ID
        T []byte `bencode:"t"`
        // required: type of the message: q for QUERY, r for RESPONSE, e for ERROR
        Y string `bencode:"y"`
        // RESPONSE type only
        R ResponseValues `bencode:"r,omitempty"`
        // ERROR type only
        E Error `bencode:"e,omitempty"`
}

type QueryArguments struct {
        // ID of the querying Node
        ID []byte `bencode:"id"`
        // InfoHash of the torrent
        InfoHash []byte `bencode:"info_hash,omitempty"`
        // ID of the node sought
        Target []byte `bencode:"target,omitempty"`
        // Token received from an earlier get_peers query
        Token []byte `bencode:"token,omitempty"`
        // Senders torrent port
        Port int `bencode:"port,omitempty"`
        // Use senders apparent DHT port
        ImpliedPort int `bencode:"implied_port,omitempty"`

        // Indicates whether the querying node is seeding the torrent it announces.
        // Defined in BEP 33 "DHT Scrapes" for `announce_peer` queries.
        Seed int `bencode:"seed,omitempty"`

        // If 1, then the responding node should try to fill the `values` list with non-seed items on a
        // best-effort basis."
        // Defined in BEP 33 "DHT Scrapes" for `get_peers` queries.
        NoSeed int `bencode:"noseed,omitempty"`
        // If 1, then the responding node should add two fields to the "r" dictionary in the response:
        //   - `BFsd`: Bloom Filter (256 bytes) representing all stored seeds for that infohash
        //   - `BFpe`: Bloom Filter (256 bytes) representing all stored peers (leeches) for that
        //             infohash
        // Defined in BEP 33 "DHT Scrapes" for `get_peers` queries.
        Scrape int `bencode:"noseed,omitempty"`
}

type ResponseValues struct {
        // ID of the querying node
        ID []byte `bencode:"id"`
        // K closest ipv4 nodes to the requested target
        Nodes CompactNodeInfos `bencode:"nodes,omitempty"`
        // K closest ipv6 nodes to the requested target
        Nodes6 CompactNodeInfos `bencode:"nodes6,omitempty"`
        // Token for future announce_peer
        Token []byte `bencode:"token,omitempty"`
        // Torrent peers
        Values []CompactPeer `bencode:"values,omitempty"`

        // The subset refresh interval in seconds. Added by BEP 51.
        Interval int `bencode:"interval,omitempty"`
        // Number of infohashes in storage. Added by BEP 51.
        Num int `bencode:"num,omitempty"`
        // Subset of stored infohashes, N  20 bytes. Added by BEP 51.
        Samples []byte `bencode:"samples,omitempty"`

        // If `scrape` is set to 1 in the `get_peers` query then the responding node should add the
        // below two fields to the "r" dictionary in the response:
        // Defined in BEP 33 "DHT Scrapes" for responses to `get_peers` queries.
        // Bloom Filter (256 bytes) representing all stored seeds for that infohash:
        BFsd *bloom.BloomFilter `bencode:"BFsd,omitempty"`
        // Bloom Filter (256 bytes) representing all stored peers (leeches) for that infohash:
        BFpe *bloom.BloomFilter `bencode:"BFpe,omitempty"`
        // TODO: write marshallers for those fields above ^^
}

type Error struct {
        Code    int
        Message []byte
}

// Represents peer address in either IPv6 or IPv4 form.
type CompactPeer struct {
        IP   net.IP
        Port int
}

type CompactPeers []CompactPeer

type CompactNodeInfo struct {
        ID   []byte
        Addr net.UDPAddr
}

type CompactNodeInfos []CompactNodeInfo

// This allows bencode.Unmarshal to do better than a string or []byte.
func (cps *CompactPeers) UnmarshalBencode(b []byte) (err error) <span class="cov0" title="0">{
        var bb []byte
        err = bencode.Unmarshal(b, &amp;bb)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">*cps, err = UnmarshalCompactPeers(bb)
        return</span>
}

func (cps CompactPeers) MarshalBinary() (ret []byte, err error) <span class="cov8" title="1">{
        ret = []byte{}
        for _, cp := range cps </span><span class="cov8" title="1">{
                ip := cp.IP.To4()
                partial := make([]byte, 6) // For IPv4
                if ip == nil </span><span class="cov8" title="1">{
                        ip = cp.IP.To16()
                        partial = make([]byte, 18) // For IPv6
                }</span>
                <span class="cov8" title="1">copy(partial, ip)
                binary.BigEndian.PutUint16(partial[len(ip):], uint16(cp.Port))
                ret = append(ret, partial...)</span>
        }
        <span class="cov8" title="1">return</span>
}

func (cp CompactPeer) MarshalBencode() (ret []byte, err error) <span class="cov8" title="1">{
        ip := cp.IP
        if ip4 := ip.To4(); ip4 != nil </span><span class="cov8" title="1">{
                ip = ip4
        }</span>
        <span class="cov8" title="1">ret = make([]byte, len(ip)+2)
        copy(ret, ip)
        binary.BigEndian.PutUint16(ret[len(ip):], uint16(cp.Port))
        return bencode.Marshal(ret)</span>
}

func (cp *CompactPeer) UnmarshalBinary(b []byte) error <span class="cov8" title="1">{
        switch len(b) </span>{
        case 18:<span class="cov8" title="1">
                cp.IP = make([]byte, 16)</span>
        case 6:<span class="cov8" title="1">
                cp.IP = make([]byte, 4)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("bad compact peer string: %q", b)</span>
        }
        <span class="cov8" title="1">copy(cp.IP, b)
        b = b[len(cp.IP):]
        cp.Port = int(binary.BigEndian.Uint16(b))
        return nil</span>
}

func (cp *CompactPeer) UnmarshalBencode(b []byte) (err error) <span class="cov8" title="1">{
        var _b []byte
        err = bencode.Unmarshal(b, &amp;_b)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return cp.UnmarshalBinary(_b)</span>
}

func UnmarshalCompactPeers(b []byte) (ret []CompactPeer, err error) <span class="cov8" title="1">{
        riddle := 0
        if len(b)%18 == 0 </span><span class="cov8" title="1">{
                riddle = 18
        }</span> else<span class="cov8" title="1"> if len(b)%6 == 0 </span><span class="cov8" title="1">{
                riddle = 6
        }</span>

        <span class="cov8" title="1">num := len(b) / riddle
        ret = make([]CompactPeer, num)
        for i := range make([]struct{}, num) </span><span class="cov8" title="1">{
                off := i * riddle
                err = ret[i].UnmarshalBinary(b[off : off+riddle])
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// This allows bencode.Unmarshal to do better than a string or []byte.
func (cnis *CompactNodeInfos) UnmarshalBencode(b []byte) (err error) <span class="cov8" title="1">{
        var bb []byte
        err = bencode.Unmarshal(b, &amp;bb)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">*cnis, err = UnmarshalCompactNodeInfos(bb)
        return</span>
}

func UnmarshalCompactNodeInfos(b []byte) (ret []CompactNodeInfo, err error) <span class="cov8" title="1">{
        if len(b)%38 != 0 &amp;&amp; len(b)%26 != 0 </span><span class="cov0" title="0">{
                err = fmt.Errorf("compact node is not a multiple of 26 (IPv4) or 38 (IPv6)")
                return
        }</span>

        <span class="cov8" title="1">var nodeSize int
        if len(b)%38 == 0 </span><span class="cov8" title="1">{
                nodeSize = 38
        }</span> else<span class="cov8" title="1"> {
                nodeSize = 26
        }</span>

        <span class="cov8" title="1">num := len(b) / nodeSize
        ret = make([]CompactNodeInfo, num)
        for i := range make([]struct{}, num) </span><span class="cov8" title="1">{
                off := i * nodeSize
                ret[i].ID = make([]byte, 20)
                err = ret[i].UnmarshalBinary(b[off : off+nodeSize])
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (cni *CompactNodeInfo) UnmarshalBinary(b []byte) error <span class="cov8" title="1">{
        copy(cni.ID[:], b)
        b = b[len(cni.ID):]
        cni.Addr.IP = make([]byte, len(b)-2)
        copy(cni.Addr.IP, b)
        b = b[len(cni.Addr.IP):]
        cni.Addr.Port = int(binary.BigEndian.Uint16(b))
        cni.Addr.Zone = ""
        return nil
}</span>

func (cnis CompactNodeInfos) MarshalBencode() ([]byte, error) <span class="cov8" title="1">{
        var ret []byte

        if len(cnis) == 0 </span><span class="cov8" title="1">{
                return []byte("0:"), nil
        }</span>

        <span class="cov8" title="1">for _, cni := range cnis </span><span class="cov8" title="1">{
                ret = append(ret, cni.MarshalBinary()...)
        }</span>

        <span class="cov8" title="1">return bencode.Marshal(ret)</span>
}

func (cni CompactNodeInfo) MarshalBinary() []byte <span class="cov8" title="1">{
        ret := make([]byte, 20)
        copy(ret, cni.ID)

        ip := cni.Addr.IP.To4()
        if ip == nil </span><span class="cov8" title="1">{
                ip = cni.Addr.IP.To16()
        }</span>
        <span class="cov8" title="1">ret = append(ret, ip...)

        portEncoding := make([]byte, 2)
        binary.BigEndian.PutUint16(portEncoding, uint16(cni.Addr.Port))
        ret = append(ret, portEncoding...)

        return ret</span>
}

func (e Error) MarshalBencode() ([]byte, error) <span class="cov8" title="1">{
        return []byte(fmt.Sprintf("li%de%d:%se", e.Code, len(e.Message), e.Message)), nil
}</span>

func (e *Error) UnmarshalBencode(b []byte) (err error) <span class="cov8" title="1">{
        var code, msgLen int

        result := regexp.MustCompile(`li([0-9]+)e([0-9]+):(.+)e`).FindAllSubmatch(b, 1)
        if len(result) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("could not parse the error list")
        }</span>

        <span class="cov8" title="1">matches := result[0][1:]
        if _, err := fmt.Sscanf(string(matches[0]), "%d", &amp;code); err != nil </span><span class="cov0" title="0">{
                return errors.New("could not parse error code " + err.Error())
        }</span>
        <span class="cov8" title="1">if _, err := fmt.Sscanf(string(matches[1]), "%d", &amp;msgLen); err != nil </span><span class="cov0" title="0">{
                return errors.New("could not parse error msg length " + err.Error())
        }</span>

        <span class="cov8" title="1">if len(matches[2]) != msgLen </span><span class="cov0" title="0">{
                return fmt.Errorf("error message have different lengths (%d vs %d) \"%s\"", len(matches[2]), msgLen, matches[2])
        }</span>

        <span class="cov8" title="1">e.Code = code
        e.Message = matches[2]

        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package mainline

import (
        "crypto/rand"
        "encoding/binary"
        mrand "math/rand/v2"
        "net"
        "reflect"
        "strconv"
        "time"

        "tgragnato.it/magnetico/v2/stats"
)

type IndexingService struct {
        // Private
        protocol      *Protocol
        started       bool
        eventHandlers IndexingServiceEventHandlers

        nodeID []byte
        nodes  *routingTable

        counter          uint16
        getPeersRequests map[[2]byte][20]byte // GetPeersQuery.`t` -&gt; infohash

        bootstrapNodes []string
}

type IndexingServiceEventHandlers struct {
        OnResult func(IndexingResult)
}

type IndexingResult struct {
        infoHash  [20]byte
        peerAddrs []net.TCPAddr
}

func (ir IndexingResult) InfoHash() [20]byte <span class="cov0" title="0">{
        return ir.infoHash
}</span>

func (ir IndexingResult) PeerAddrs() []net.TCPAddr <span class="cov0" title="0">{
        return ir.peerAddrs
}</span>

func NewIndexingService(laddr string, maxNeighbors uint, eventHandlers IndexingServiceEventHandlers, bootstrapNodes []string, filterNodes []net.IPNet) *IndexingService <span class="cov8" title="1">{
        service := new(IndexingService)
        service.protocol = NewProtocol(
                laddr,
                ProtocolEventHandlers{
                        OnPingQuery:                  service.onPingQuery,
                        OnFindNodeQuery:              service.onFindNodeQuery,
                        OnGetPeersQuery:              service.onGetPeersQuery,
                        OnAnnouncePeerQuery:          service.onAnnouncePeerQuery,
                        OnGetPeersResponse:           service.onGetPeersResponse,
                        OnFindNodeResponse:           service.onFindNodeResponse,
                        OnPingORAnnouncePeerResponse: service.onPingORAnnouncePeerResponse,
                        OnSampleInfohashesQuery:      service.onSampleInfohashesQuery,
                        OnSampleInfohashesResponse:   service.onSampleInfohashesResponse,
                },
                maxNeighbors,
        )
        service.nodeID = randomNodeID()
        service.nodes = newRoutingTable(maxNeighbors, filterNodes)
        service.eventHandlers = eventHandlers

        service.getPeersRequests = make(map[[2]byte][20]byte)
        service.bootstrapNodes = bootstrapNodes

        return service
}</span>

func (is *IndexingService) Start() <span class="cov8" title="1">{
        if is.started </span><span class="cov0" title="0">{
                panic("Attempting to Start() a mainline/IndexingService that has been already started!")</span>
        }
        <span class="cov8" title="1">is.started = true

        is.protocol.Start()
        go is.index()</span>
}

func (is *IndexingService) Terminate() <span class="cov8" title="1">{
        is.protocol.Terminate()
}</span>

func (is *IndexingService) index() <span class="cov8" title="1">{
        ticker := time.NewTicker(time.Second)
        for ; true; &lt;-ticker.C </span><span class="cov8" title="1">{
                if is.nodes.isEmpty() </span><span class="cov8" title="1">{
                        is.bootstrap()
                }</span> else<span class="cov0" title="0"> if !is.protocol.transport.Full() </span><span class="cov0" title="0">{
                        is.findNeighbors()
                }</span>
        }
}

func (is *IndexingService) bootstrap() <span class="cov8" title="1">{
        for _, node := range is.bootstrapNodes </span><span class="cov8" title="1">{
                dnsName, portStr, err := net.SplitHostPort(node)
                if err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">port, err := strconv.Atoi(portStr)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">bootstrappingIPs := []net.IP{}
                if ipAddrs, err := net.LookupIP(dnsName); err == nil </span><span class="cov0" title="0">{
                        bootstrappingIPs = append(bootstrappingIPs, ipAddrs...)
                }</span>

                <span class="cov0" title="0">if len(bootstrappingIPs) == 0 || port == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, ip := range bootstrappingIPs </span><span class="cov0" title="0">{
                        go is.protocol.SendMessage(
                                NewFindNodeQuery(is.nodeID, randomNodeID()),
                                &amp;net.UDPAddr{IP: ip, Port: port},
                        )
                }</span>
        }

        <span class="cov8" title="1">go stats.GetInstance().IncBootstrap()</span>
}

func (is *IndexingService) findNeighbors() <span class="cov8" title="1">{
        for _, addr := range is.nodes.getNodes() </span><span class="cov0" title="0">{
                go is.protocol.SendMessage(
                        NewSampleInfohashesQuery(is.nodeID, []byte("aa"), randomNodeID()),
                        &amp;addr,
                )
        }</span>
}

func (is *IndexingService) onFindNodeResponse(response *Message, addr *net.UDPAddr) <span class="cov8" title="1">{
        neighbors := []net.UDPAddr{}
        for _, node := range response.R.Nodes </span><span class="cov8" title="1">{
                neighbors = append(neighbors, node.Addr)
        }</span>
        <span class="cov8" title="1">for _, node := range response.R.Nodes6 </span><span class="cov0" title="0">{
                neighbors = append(neighbors, node.Addr)
        }</span>

        <span class="cov8" title="1">if len(neighbors) &gt; 0 </span><span class="cov8" title="1">{
                go is.nodes.addNodes(neighbors)
        }</span>
}

func (is *IndexingService) onGetPeersResponse(msg *Message, addr *net.UDPAddr) <span class="cov8" title="1">{
        var t [2]byte
        copy(t[:], msg.T)

        infoHash := is.getPeersRequests[t]
        // We got a response, so free the key!
        delete(is.getPeersRequests, t)

        // BEP 51 specifies that
        //     The new sample_infohashes remote procedure call requests that a remote node return a string of multiple
        //     concatenated infohashes (20 bytes each) FOR WHICH IT HOLDS GET_PEERS VALUES.
        //                                                                          ^^^^^^
        // So theoretically we should never hit the case where `values` is empty, but c'est la vie.
        if len(msg.R.Values) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">peerAddrs := make([]net.TCPAddr, 0)
        for _, peer := range msg.R.Values </span><span class="cov8" title="1">{
                if peer.Port == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">peerAddrs = append(peerAddrs, net.TCPAddr{
                        IP:   peer.IP,
                        Port: peer.Port,
                })</span>
        }

        <span class="cov8" title="1">go is.eventHandlers.OnResult(IndexingResult{
                infoHash:  infoHash,
                peerAddrs: peerAddrs,
        })</span>
}

func (is *IndexingService) onSampleInfohashesResponse(msg *Message, addr *net.UDPAddr) <span class="cov8" title="1">{
        info_hashes := [][20]byte{}

        // request samples
        for i := 0; i &lt; len(msg.R.Samples)/20; i++ </span><span class="cov8" title="1">{
                var infoHash [20]byte
                copy(infoHash[:], msg.R.Samples[i:(i+1)*20])
                info_hashes = append(info_hashes, infoHash)

                msg := NewGetPeersQuery(is.nodeID, infoHash[:])
                t := toBigEndianBytes(is.counter)
                msg.T = t[:]

                is.protocol.SendMessage(msg, addr)

                is.getPeersRequests[t] = infoHash
                is.counter++
        }</span>

        <span class="cov8" title="1">go is.nodes.addHashes(info_hashes)

        neighbors := []net.UDPAddr{}
        if msg.R.Num &gt; len(msg.R.Samples)/20 &amp;&amp; time.Duration(msg.R.Interval) &lt;= time.Minute </span><span class="cov0" title="0">{
                neighbors = append(neighbors, *addr)
        }</span>
        <span class="cov8" title="1">for _, node := range msg.R.Nodes </span><span class="cov8" title="1">{
                neighbors = append(neighbors, node.Addr)
        }</span>
        <span class="cov8" title="1">for _, node := range msg.R.Nodes6 </span><span class="cov0" title="0">{
                neighbors = append(neighbors, node.Addr)
        }</span>
        <span class="cov8" title="1">if len(neighbors) &gt; 0 </span><span class="cov8" title="1">{
                go is.nodes.addNodes(neighbors)
        }</span>
}

func (is *IndexingService) onPingORAnnouncePeerResponse(msg *Message, addr *net.UDPAddr) <span class="cov8" title="1">{
        go is.nodes.addNodes([]net.UDPAddr{*addr})
}</span>

func (is *IndexingService) onPingQuery(msg *Message, addr *net.UDPAddr) <span class="cov8" title="1">{
        go is.nodes.addNodes([]net.UDPAddr{*addr})

        go is.protocol.SendMessage(
                NewPingResponse(msg.T, is.nodeID),
                addr,
        )
}</span>

func (is *IndexingService) onAnnouncePeerQuery(msg *Message, addr *net.UDPAddr) <span class="cov8" title="1">{
        addresses := []net.UDPAddr{*addr}

        if msg.A.Port &gt; 0 &amp;&amp;
                msg.A.Port &lt;= 65535 &amp;&amp;
                addr.Port != msg.A.Port </span><span class="cov8" title="1">{
                addresses = append(addresses, net.UDPAddr{
                        IP:   addr.IP,
                        Port: msg.A.Port,
                })
        }</span>

        <span class="cov8" title="1">if msg.A.ImpliedPort &gt; 0 &amp;&amp;
                msg.A.ImpliedPort &lt;= 65535 &amp;&amp;
                addr.Port != msg.A.ImpliedPort &amp;&amp;
                msg.A.Port != msg.A.ImpliedPort </span><span class="cov8" title="1">{
                addresses = append(addresses, net.UDPAddr{
                        IP:   addr.IP,
                        Port: msg.A.ImpliedPort,
                })
        }</span>

        <span class="cov8" title="1">go is.nodes.addNodes(addresses)

        go is.protocol.SendMessage(
                NewAnnouncePeerResponse(msg.T, is.nodeID),
                addr,
        )</span>
}

func (is *IndexingService) onFindNodeQuery(msg *Message, addr *net.UDPAddr) <span class="cov8" title="1">{
        compactNodeInfos := []CompactNodeInfo{}
        for _, node := range is.nodes.dump(addr.IP.To4() != nil) </span><span class="cov0" title="0">{
                compactNodeInfos = append(compactNodeInfos, CompactNodeInfo{
                        ID:   randomNodeID(),
                        Addr: node,
                })
        }</span>

        <span class="cov8" title="1">go is.protocol.SendMessage(
                NewFindNodeResponse(msg.T, is.nodeID, compactNodeInfos),
                addr,
        )

        go is.nodes.addNodes([]net.UDPAddr{*addr})</span>
}

func (is *IndexingService) onGetPeersQuery(msg *Message, addr *net.UDPAddr) <span class="cov8" title="1">{
        compactPeers := []CompactPeer{}
        for _, node := range is.nodes.dump(addr.IP.To4() != nil) </span><span class="cov0" title="0">{
                compactPeers = append(compactPeers, CompactPeer{
                        IP:   node.IP,
                        Port: node.Port,
                })
        }</span>

        <span class="cov8" title="1">go is.protocol.SendMessage(
                NewGetPeersResponseWithValues(
                        msg.T,
                        is.nodeID,
                        is.protocol.CalculateToken(addr.IP),
                        compactPeers,
                ),
                addr,
        )

        go is.nodes.addNodes([]net.UDPAddr{*addr})</span>
}

func (is *IndexingService) onSampleInfohashesQuery(msg *Message, addr *net.UDPAddr) <span class="cov0" title="0">{
        go is.nodes.addNodes([]net.UDPAddr{*addr})

        // the remote is an indexer, send a find_node query to obtain some peers
        go is.protocol.SendMessage(
                NewFindNodeQuery(is.nodeID, randomNodeID()),
                addr,
        )

        hash_stream := []byte{}
        for _, info_hash := range is.nodes.getHashes() </span><span class="cov0" title="0">{
                if !reflect.DeepEqual(info_hash, [20]byte{}) </span><span class="cov0" title="0">{
                        hash_stream = append(hash_stream, info_hash[:]...)
                }</span>
        }
        <span class="cov0" title="0">if len(hash_stream) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">go is.protocol.SendMessage(
                NewSampleInfohashesResponse(
                        msg.T,
                        is.nodeID,
                        hash_stream,
                ),
                addr,
        )</span>
}

// toBigEndianBytes Convert UInt16 To BigEndianBytes
func toBigEndianBytes(v uint16) [2]byte <span class="cov8" title="1">{
        var b [2]byte
        binary.BigEndian.PutUint16(b[:], v)
        return b
}</span>

func randomNodeID() []byte <span class="cov8" title="1">{
        nodeID := make([]byte, 20)
        _, err := rand.Read(nodeID)
        if err != nil </span><span class="cov0" title="0">{
                for i := 0; i &lt; 20; i++ </span><span class="cov0" title="0">{
                        nodeID[i] = byte(mrand.IntN(256))
                }</span>
        }
        <span class="cov8" title="1">return nodeID</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package mainline

import (
        "bytes"
        "crypto/rand"
        "crypto/sha1"
        mrand "math/rand/v2"
        "net"
        "sync"
        "time"

        "tgragnato.it/magnetico/v2/stats"
)

type Protocol struct {
        tokenSecret   []byte
        tokenLock     sync.Mutex
        transport     *Transport
        eventHandlers ProtocolEventHandlers
        started       bool
}

type ProtocolEventHandlers struct {
        OnPingQuery                  func(*Message, *net.UDPAddr)
        OnFindNodeQuery              func(*Message, *net.UDPAddr)
        OnGetPeersQuery              func(*Message, *net.UDPAddr)
        OnAnnouncePeerQuery          func(*Message, *net.UDPAddr)
        OnGetPeersResponse           func(*Message, *net.UDPAddr)
        OnFindNodeResponse           func(*Message, *net.UDPAddr)
        OnPingORAnnouncePeerResponse func(*Message, *net.UDPAddr)

        // Added by BEP 51
        OnSampleInfohashesQuery    func(*Message, *net.UDPAddr)
        OnSampleInfohashesResponse func(*Message, *net.UDPAddr)
}

func NewProtocol(laddr string, eventHandlers ProtocolEventHandlers, maxNeighbors uint) (p *Protocol) <span class="cov8" title="1">{
        p = new(Protocol)
        p.eventHandlers = eventHandlers
        p.transport = NewTransport(laddr, p.onMessage, maxNeighbors)
        return
}</span>

func (p *Protocol) Start() <span class="cov8" title="1">{
        if p.started </span><span class="cov8" title="1">{
                panic("Attempting to Start() a mainline/Protocol that has been already started!")</span>
        }
        <span class="cov8" title="1">p.started = true

        p.transport.Start()
        p.updateTokenSecret()

        go func() </span><span class="cov8" title="1">{
                for range time.NewTicker(10 * time.Minute).C </span><span class="cov0" title="0">{
                        p.updateTokenSecret()
                }</span>
        }()
}

func (p *Protocol) Terminate() <span class="cov8" title="1">{
        if !p.started </span><span class="cov8" title="1">{
                panic("Attempted to Terminate() a mainline/Protocol that has not been Start()ed!")</span>
        }

        <span class="cov8" title="1">p.transport.Terminate()</span>
}

func (p *Protocol) onMessage(msg *Message, addr *net.UDPAddr) <span class="cov8" title="1">{
        switch msg.Y </span>{
        case "q":<span class="cov8" title="1">
                switch msg.Q </span>{
                case "ping":<span class="cov8" title="1">
                        if !validatePingQueryMessage(msg) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        // Check whether there is a registered event handler for the ping queries, before
                        // attempting to call.
                        <span class="cov8" title="1">if p.eventHandlers.OnPingQuery != nil </span><span class="cov8" title="1">{
                                p.eventHandlers.OnPingQuery(msg, addr)
                        }</span>

                case "find_node":<span class="cov8" title="1">
                        if !validateFindNodeQueryMessage(msg) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">if p.eventHandlers.OnFindNodeQuery != nil </span><span class="cov8" title="1">{
                                p.eventHandlers.OnFindNodeQuery(msg, addr)
                        }</span>

                case "get_peers":<span class="cov8" title="1">
                        if !validateGetPeersQueryMessage(msg) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">if p.eventHandlers.OnGetPeersQuery != nil </span><span class="cov8" title="1">{
                                p.eventHandlers.OnGetPeersQuery(msg, addr)
                        }</span>

                case "announce_peer":<span class="cov8" title="1">
                        if !validateAnnouncePeerQueryMessage(msg) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">if p.eventHandlers.OnAnnouncePeerQuery != nil </span><span class="cov8" title="1">{
                                p.eventHandlers.OnAnnouncePeerQuery(msg, addr)
                        }</span>

                case "sample_infohashes":<span class="cov8" title="1"> // Added by BEP 51
                        if !validateSampleInfohashesQueryMessage(msg) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">if p.eventHandlers.OnSampleInfohashesQuery != nil </span><span class="cov8" title="1">{
                                p.eventHandlers.OnSampleInfohashesQuery(msg, addr)
                        }</span>

                default:<span class="cov0" title="0">
                        return</span>
                }
        case "r":<span class="cov8" title="1">
                // Query messages have a `q` field which indicates their type but response messages have no such field that we
                // can rely on.
                // The idea is you'd use transaction ID (the `t` key) to deduce the type of a response message, as it must be
                // sent in response to a query message (with the same transaction ID) that we have sent earlier.
                // This approach is, unfortunately, not very practical for our needs since we send up to thousands messages per
                // second, meaning that we'd run out of transaction IDs very quickly (since some [many?] clients assume
                // transaction IDs are no longer than 2 bytes), and we'd also then have to consider retention too (as we might
                // not get a response at all).
                // Our approach uses an ad-hoc pattern matching: all response messages share a subset of fields (such as `t`,
                // `y`) but only one type of them contain a particular field (such as `token` field is unique to `get_peers`
                // responses, `samples` is unique to `sample_infohashes` etc).
                //
                // sample_infohashes &gt; get_peers &gt; find_node &gt; ping / announce_peer
                if len(msg.R.Samples) != 0 </span><span class="cov8" title="1">{ // The message should be a sample_infohashes response.
                        if !validateSampleInfohashesResponseMessage(msg) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">if p.eventHandlers.OnSampleInfohashesResponse != nil </span><span class="cov8" title="1">{
                                p.eventHandlers.OnSampleInfohashesResponse(msg, addr)
                        }</span>
                } else<span class="cov8" title="1"> if len(msg.R.Token) != 0 </span><span class="cov8" title="1">{ // The message should be a get_peers response.
                        if !validateGetPeersResponseMessage(msg) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">if p.eventHandlers.OnGetPeersResponse != nil </span><span class="cov8" title="1">{
                                p.eventHandlers.OnGetPeersResponse(msg, addr)
                        }</span>
                } else<span class="cov8" title="1"> if len(msg.R.Nodes) != 0 || len(msg.R.Nodes6) != 0 </span><span class="cov8" title="1">{ // The message should be a find_node response.
                        if !validateFindNodeResponseMessage(msg) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">if p.eventHandlers.OnFindNodeResponse != nil </span><span class="cov8" title="1">{
                                p.eventHandlers.OnFindNodeResponse(msg, addr)
                        }</span>
                } else<span class="cov8" title="1"> { // The message should be a ping or an announce_peer response.
                        if !validatePingORannouncePeerResponseMessage(msg) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">if p.eventHandlers.OnPingORAnnouncePeerResponse != nil </span><span class="cov8" title="1">{
                                p.eventHandlers.OnPingORAnnouncePeerResponse(msg, addr)
                        }</span>
                }
        default:<span class="cov0" title="0"></span>
        }
}

func (p *Protocol) SendMessage(msg *Message, addr *net.UDPAddr) <span class="cov8" title="1">{
        if addr.Port &lt; 1 || addr.Port &gt; 65535 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if err := p.transport.WriteMessages(msg, addr); err != nil </span><span class="cov8" title="1">{
                go stats.GetInstance().IncUDPError(true)
        }</span>
}

func NewPingQuery(id []byte) *Message <span class="cov8" title="1">{
        return &amp;Message{
                Y: "q",
                T: []byte("aa"),
                Q: "ping",
                A: QueryArguments{
                        ID: id,
                },
        }
}</span>

func NewFindNodeQuery(id []byte, target []byte) *Message <span class="cov8" title="1">{
        return &amp;Message{
                Y: "q",
                T: []byte("aa"),
                Q: "find_node",
                A: QueryArguments{
                        ID:     id,
                        Target: target,
                },
        }
}</span>

func NewGetPeersQuery(id []byte, infoHash []byte) *Message <span class="cov8" title="1">{
        return &amp;Message{
                Y: "q",
                T: []byte("aa"),
                Q: "get_peers",
                A: QueryArguments{
                        ID:       id,
                        InfoHash: infoHash,
                },
        }
}</span>

func NewAnnouncePeerQuery(id []byte, implied_port bool, info_hash []byte, port uint16, token []byte) *Message <span class="cov8" title="1">{
        if implied_port </span><span class="cov8" title="1">{
                return &amp;Message{
                        Y: "q",
                        T: []byte("aa"),
                        Q: "announce_peer",
                        A: QueryArguments{
                                ID:          id,
                                ImpliedPort: int(port),
                                InfoHash:    info_hash,
                                Port:        int(port),
                                Token:       token,
                        },
                }
        }</span>

        <span class="cov8" title="1">return &amp;Message{
                Y: "q",
                T: []byte("aa"),
                Q: "announce_peer",
                A: QueryArguments{
                        ID:       id,
                        InfoHash: info_hash,
                        Port:     int(port),
                        Token:    token,
                },
        }</span>
}

func NewSampleInfohashesQuery(id []byte, t []byte, target []byte) *Message <span class="cov8" title="1">{
        return &amp;Message{
                Y: "q",
                T: t,
                Q: "sample_infohashes",
                A: QueryArguments{
                        ID:     id,
                        Target: target,
                },
        }
}</span>

func NewPingResponse(t []byte, id []byte) *Message <span class="cov8" title="1">{
        return &amp;Message{
                Y: "r",
                T: t,
                R: ResponseValues{
                        ID: id,
                },
        }
}</span>

func NewFindNodeResponse(t []byte, id []byte, nodes []CompactNodeInfo) *Message <span class="cov8" title="1">{
        // Assumes that all nodes are IPv4 or all are IPv6.
        if len(nodes) &gt; 0 &amp;&amp; nodes[0].Addr.IP.To4() != nil </span><span class="cov8" title="1">{
                return &amp;Message{
                        Y: "r",
                        T: t,
                        R: ResponseValues{
                                ID:    id,
                                Nodes: nodes,
                        },
                }
        }</span>

        <span class="cov8" title="1">return &amp;Message{
                Y: "r",
                T: t,
                R: ResponseValues{
                        ID:     id,
                        Nodes6: nodes,
                },
        }</span>
}

func NewGetPeersResponseWithValues(t []byte, id []byte, token []byte, values []CompactPeer) *Message <span class="cov8" title="1">{
        return &amp;Message{
                Y: "r",
                T: t,
                R: ResponseValues{
                        ID:     id,
                        Token:  token,
                        Values: values,
                },
        }
}</span>

func NewGetPeersResponseWithNodes(t []byte, id []byte, token []byte, nodes []CompactNodeInfo) *Message <span class="cov8" title="1">{
        return &amp;Message{
                Y: "r",
                T: t,
                R: ResponseValues{
                        ID:    id,
                        Token: token,
                        Nodes: nodes,
                },
        }
}</span>

func NewSampleInfohashesResponse(t []byte, id []byte, info_hashes []byte) *Message <span class="cov8" title="1">{
        return &amp;Message{
                Y: "r",
                T: t,
                R: ResponseValues{
                        ID:       id,
                        Interval: 30,
                        Num:      len(info_hashes) / 20,
                        Samples:  info_hashes,
                },
        }
}</span>

func NewAnnouncePeerResponse(t []byte, id []byte) *Message <span class="cov8" title="1">{
        // Because they are indistinguishable.
        return NewPingResponse(t, id)
}</span>

func (p *Protocol) CalculateToken(address net.IP) []byte <span class="cov8" title="1">{
        p.tokenLock.Lock()
        defer p.tokenLock.Unlock()
        sum := sha1.Sum(append(p.tokenSecret, address...))
        return sum[:]
}</span>

func (p *Protocol) VerifyToken(address net.IP, token []byte) bool <span class="cov8" title="1">{
        p.tokenLock.Lock()
        defer p.tokenLock.Unlock()
        // Compare the provided token with the calculated token
        calculatedToken := sha1.Sum(append(p.tokenSecret, address...))
        return bytes.Equal(calculatedToken[:], token)
}</span>

func (p *Protocol) updateTokenSecret() <span class="cov8" title="1">{
        p.tokenLock.Lock()
        defer p.tokenLock.Unlock()
        _, err := rand.Read(p.tokenSecret)
        if err != nil </span><span class="cov0" title="0">{
                len := mrand.IntN(256)
                p.tokenSecret = make([]byte, len)
                for i := 0; i &lt; len; i++ </span><span class="cov0" title="0">{
                        p.tokenSecret[i] = byte(mrand.IntN(256))
                }</span>
        }
}

func validatePingQueryMessage(msg *Message) bool <span class="cov8" title="1">{
        return len(msg.A.ID) == 20
}</span>

func validateFindNodeQueryMessage(msg *Message) bool <span class="cov8" title="1">{
        return len(msg.A.ID) == 20 &amp;&amp;
                len(msg.A.Target) == 20
}</span>

func validateGetPeersQueryMessage(msg *Message) bool <span class="cov8" title="1">{
        return len(msg.A.ID) == 20 &amp;&amp;
                len(msg.A.InfoHash) == 20
}</span>

func validateAnnouncePeerQueryMessage(msg *Message) bool <span class="cov8" title="1">{
        return len(msg.A.ID) == 20 &amp;&amp;
                len(msg.A.InfoHash) == 20 &amp;&amp;
                msg.A.Port &gt; 0 &amp;&amp;
                len(msg.A.Token) &gt; 0
}</span>

func validateSampleInfohashesQueryMessage(msg *Message) bool <span class="cov8" title="1">{
        return len(msg.A.ID) == 20 &amp;&amp;
                len(msg.A.Target) == 20
}</span>

func validatePingORannouncePeerResponseMessage(msg *Message) bool <span class="cov8" title="1">{
        return len(msg.R.ID) == 20
}</span>

func validateFindNodeResponseMessage(msg *Message) bool <span class="cov8" title="1">{
        return len(msg.R.ID) == 20 &amp;&amp;
                (len(msg.R.Nodes) &gt;= 0 || len(msg.R.Nodes6) &gt;= 0)
}</span>

func validateGetPeersResponseMessage(msg *Message) bool <span class="cov8" title="1">{
        return len(msg.R.ID) == 20 &amp;&amp;
                len(msg.R.Token) &gt; 0 &amp;&amp;
                (len(msg.R.Values) &gt; 0 || len(msg.R.Nodes) &gt;= 0 || len(msg.R.Nodes6) &gt;= 0)
}</span>

func validateSampleInfohashesResponseMessage(msg *Message) bool <span class="cov8" title="1">{
        return len(msg.R.ID) == 20 &amp;&amp;
                msg.R.Interval &gt;= 0 &amp;&amp;
                (len(msg.R.Nodes) &gt;= 0 || len(msg.R.Nodes6) &gt;= 0) &amp;&amp;
                msg.R.Num &gt;= 0 &amp;&amp;
                len(msg.R.Samples)%20 == 0
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package mainline

import (
        "net"
        "strconv"
        "sync"

        "tgragnato.it/magnetico/v2/stats"
)

type routingTable struct {
        sync.RWMutex
        nodes        map[string]uint
        maxNeighbors uint
        filterNodes  []net.IPNet
        info_hashes  [10][20]byte
}

func newRoutingTable(maxNeighbors uint, filterNodes []net.IPNet) *routingTable <span class="cov8" title="1">{
        return &amp;routingTable{
                nodes:        map[string]uint{},
                maxNeighbors: maxNeighbors,
                filterNodes:  filterNodes,
                info_hashes:  [10][20]byte{},
        }
}</span>

func (rt *routingTable) isAllowed(node net.UDPAddr) bool <span class="cov8" title="1">{
        if len(rt.filterNodes) &gt; 0 </span><span class="cov8" title="1">{
                for _, filterNode := range rt.filterNodes </span><span class="cov8" title="1">{
                        if filterNode.Contains(node.IP) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }

                <span class="cov8" title="1">return false</span>
        }

        <span class="cov8" title="1">if !node.IP.IsGlobalUnicast() || node.IP.IsPrivate() </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if node.Port != 80 &amp;&amp; node.Port != 443 &amp;&amp;
                node.Port &lt; 1024 || node.Port &gt; 65535 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (rt *routingTable) addNodes(nodes []net.UDPAddr) <span class="cov8" title="1">{
        filteredNodes := []net.UDPAddr{}
        for _, node := range nodes </span><span class="cov8" title="1">{
                if !rt.isAllowed(node) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">filteredNodes = append(filteredNodes, node)</span>
        }
        <span class="cov8" title="1">if len(filteredNodes) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">rt.Lock()
        defer rt.Unlock()

        if len(rt.nodes)+len(filteredNodes) &gt; int(rt.maxNeighbors*rt.maxNeighbors) </span><span class="cov8" title="1">{
                for node := range rt.nodes </span><span class="cov0" title="0">{
                        delete(rt.nodes, node)
                }</span>
                <span class="cov8" title="1">go stats.GetInstance().IncRtClearing()</span>
        }

        <span class="cov8" title="1">for _, node := range filteredNodes </span><span class="cov8" title="1">{
                rt.nodes[node.String()]++
        }</span>
}

func (rt *routingTable) getNodes() []net.UDPAddr <span class="cov8" title="1">{
        rt.Lock()
        defer rt.Unlock()

        counter := uint(0)
        nodes := []net.UDPAddr{}
        for node := range rt.nodes </span><span class="cov8" title="1">{
                if counter &gt;= rt.maxNeighbors </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">addr, err := addrFromStr(node)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">nodes = append(nodes, addr)
                if rt.nodes[node] &gt; 1 </span><span class="cov0" title="0">{
                        rt.nodes[node]--
                }</span> else<span class="cov8" title="1"> {
                        delete(rt.nodes, node)
                }</span>
                <span class="cov8" title="1">counter++</span>
        }

        <span class="cov8" title="1">return nodes</span>
}

func (rt *routingTable) isEmpty() bool <span class="cov8" title="1">{
        rt.RLock()
        defer rt.RUnlock()

        return len(rt.nodes) == 0
}</span>

func (rt *routingTable) dump(ipv4 bool) []net.UDPAddr <span class="cov8" title="1">{
        rt.RLock()
        defer rt.RUnlock()

        counter := uint(0)
        nodes := []net.UDPAddr{}
        for node := range rt.nodes </span><span class="cov8" title="1">{
                if counter &gt;= 100 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">addr, err := addrFromStr(node)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if ipv4 &amp;&amp; addr.IP.To4() != nil || !ipv4 &amp;&amp; addr.IP.To4() == nil </span><span class="cov8" title="1">{
                        nodes = append(nodes, addr)
                }</span>
        }

        <span class="cov8" title="1">return nodes</span>
}

func (rt *routingTable) addHashes(info_hashes [][20]byte) <span class="cov8" title="1">{
        rt.Lock()
        defer rt.Unlock()

        for i := 0; i &lt; len(info_hashes) &amp;&amp; i &lt; 10; i++ </span><span class="cov8" title="1">{
                rt.info_hashes[i] = info_hashes[i]
        }</span>
}

func (rt *routingTable) getHashes() [10][20]byte <span class="cov8" title="1">{
        rt.RLock()
        defer rt.RUnlock()

        return rt.info_hashes
}</span>

func addrFromStr(addr string) (net.UDPAddr, error) <span class="cov8" title="1">{
        host, port, err := net.SplitHostPort(addr)
        if err != nil </span><span class="cov0" title="0">{
                return net.UDPAddr{}, err
        }</span>
        <span class="cov8" title="1">portNum, err := strconv.Atoi(port)
        if err != nil </span><span class="cov0" title="0">{
                return net.UDPAddr{}, err
        }</span>
        <span class="cov8" title="1">return net.UDPAddr{
                IP:   net.ParseIP(host),
                Port: portNum,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package mainline

import (
        "log"
        "net"
        "sync/atomic"
        "time"

        "tgragnato.it/magnetico/v2/bencode"
        "tgragnato.it/magnetico/v2/stats"
)

var (
        //Throttle rate that transport will have at Start time. Set &lt;= 0 for unlimited requests
        DefaultThrottleRate = -1
)

type Transport struct {
        conn    *net.UDPConn
        laddr   *net.UDPAddr
        started bool
        buffer  []byte

        // OnMessage is the function that will be called when Transport receives a packet that is
        // successfully unmarshalled as a syntactically correct Message (but -of course- the checking
        // the semantic correctness of the Message is left to Protocol).
        onMessage func(*Message, *net.UDPAddr)

        throttlingRate         int           //available messages per second. If &lt;=0, it is considered disabled
        throttleTicketsChannel chan struct{} //channel giving tickets (allowance) to make send a message
        maxNeighbors           uint
        queuedCommunications   uint64
}

func NewTransport(laddr string, onMessage func(*Message, *net.UDPAddr), maxNeighbors uint) *Transport <span class="cov8" title="1">{
        t := new(Transport)
        /*   The field size sets a theoretical limit of 65,535 bytes (8 byte header + 65,527 bytes of
         * data) for a UDP datagram. However the actual limit for the data length, which is imposed by
         * the underlying IPv4 protocol, is 65,507 bytes (65,535  8 byte UDP header  20 byte IP
         * header).
         *
         *   In IPv6 jumbograms it is possible to have UDP packets of size greater than 65,535 bytes.
         * RFC 2675 specifies that the length field is set to zero if the length of the UDP header plus
         * UDP data is greater than 65,535.
         *
         * https://en.wikipedia.org/wiki/User_Datagram_Protocol
         */
        t.buffer = make([]byte, 65507)
        t.onMessage = onMessage
        t.throttleTicketsChannel = make(chan struct{})
        t.throttlingRate = DefaultThrottleRate
        t.maxNeighbors = maxNeighbors
        t.queuedCommunications = 0

        var err error
        t.laddr, err = net.ResolveUDPAddr("udp", laddr)
        if err != nil </span><span class="cov0" title="0">{
                panic("Could not resolve the UDP address for the trawler! " + err.Error())</span>
        }

        <span class="cov8" title="1">return t</span>
}

func (t *Transport) Start() <span class="cov8" title="1">{
        // Why check whether the Transport `t` started or not, here and not -for instance- in
        // t.Terminate()?
        // Because in t.Terminate() the programmer (i.e. you &amp; me) would stumble upon an error while
        // trying close an uninitialised net.UDPConn or something like that: it's mostly harmless
        // because its effects are immediate. But if you try to start a Transport `t` for the second
        // (or the third, 4th, ...) time, it will keep spawning goroutines and any small mistake may
        // end up in a debugging horror.
        //                                                                   Here ends my justification.
        if t.started </span><span class="cov0" title="0">{
                panic("Attempting to Start() a mainline/Transport that has been already started!")</span>
        }
        <span class="cov8" title="1">t.started = true

        var err error
        t.conn, err = net.ListenUDP("udp", t.laddr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Could NOT bind the socket! %s\n", err.Error())
        }</span>

        <span class="cov8" title="1">go t.readMessages()
        go t.Throttle()</span>
}

func (t *Transport) Terminate() <span class="cov8" title="1">{
        t.conn.Close()
}</span>

// readMessages is a goroutine!
func (t *Transport) readMessages() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                n, from, err := t.conn.ReadFromUDP(t.buffer)
                if err != nil </span><span class="cov8" title="1">{
                        go stats.GetInstance().IncUDPError(false)
                        break</span>
                }

                <span class="cov0" title="0">if n == 0 </span><span class="cov0" title="0">{
                        /* Datagram sockets in various domains  (e.g., the UNIX and Internet domains) permit
                         * zero-length datagrams. When such a datagram is received, the return value (n) is 0.
                         */
                        continue</span>
                }

                <span class="cov0" title="0">var msg Message
                err = bencode.Unmarshal(t.buffer[:n], &amp;msg)
                if err != nil </span><span class="cov0" title="0">{
                        // couldn't unmarshal packet data
                        continue</span>
                }

                <span class="cov0" title="0">t.onMessage(&amp;msg, from)</span>
        }
}

// Manages throttling for transport. To be called as a routine at Start time. Should never return.
func (t *Transport) Throttle() <span class="cov8" title="1">{
        if t.throttlingRate &gt; 0 </span><span class="cov8" title="1">{
                resetChannel := make(chan struct{})

                dealer := func(resetRequest chan struct{}) </span><span class="cov8" title="1">{
                        ticketGiven := 0
                        tooManyTicketGiven := false
                        for </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-t.throttleTicketsChannel:<span class="cov8" title="1">
                                        </span><span class="cov8" title="1">{
                                                ticketGiven++
                                                if ticketGiven &gt;= t.throttlingRate </span><span class="cov0" title="0">{
                                                        tooManyTicketGiven = true
                                                        break</span>
                                                }
                                        }
                                case &lt;-resetRequest:<span class="cov8" title="1">
                                        </span><span class="cov8" title="1">{
                                                return
                                        }</span>
                                }

                                <span class="cov8" title="1">if tooManyTicketGiven </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">&lt;-resetRequest</span>
                }

                <span class="cov8" title="1">go dealer(resetChannel)
                for range time.Tick(1 * time.Second) </span><span class="cov8" title="1">{
                        resetChannel &lt;- struct{}{}

                        go dealer(resetChannel)
                }</span>

        } else<span class="cov8" title="1"> {
                // no limit, keep giving tickets to whoever requests it
                for </span><span class="cov8" title="1">{
                        &lt;-t.throttleTicketsChannel
                }</span>
        }
}

func (t *Transport) WriteMessages(msg *Message, addr *net.UDPAddr) error <span class="cov8" title="1">{
        if msg == nil || addr == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">data, err := bencode.Marshal(msg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // get ticket but prioritize get_peers and find_node
        <span class="cov8" title="1">if msg.Q != "get_peers" &amp;&amp; msg.Q != "find_node" </span><span class="cov8" title="1">{
                atomic.AddUint64(&amp;t.queuedCommunications, 1)
                defer atomic.AddUint64(&amp;t.queuedCommunications, ^uint64(0))
                t.throttleTicketsChannel &lt;- struct{}{}
        }</span>

        <span class="cov8" title="1">_, err = t.conn.WriteToUDP(data, addr)
        return err</span>
}

// Transport is full if the queued communications are more than the maximum neighbors.
func (t *Transport) Full() bool <span class="cov8" title="1">{
        return t.queuedCommunications &gt;= uint64(t.maxNeighbors)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package dht

import (
        "net"

        "tgragnato.it/magnetico/v2/dht/mainline"
)

type Service interface {
        Start()
        Terminate()
}

type Result interface {
        InfoHash() [20]byte
        PeerAddrs() []net.TCPAddr
}

type Manager struct {
        output           chan Result
        indexingServices []Service
}

func NewManager(addrs []string, maxNeighbors uint, bootstrappingNodes []string, filterNodes []net.IPNet) *Manager <span class="cov8" title="1">{
        manager := new(Manager)
        manager.output = make(chan Result, 20)

        for _, addr := range addrs </span><span class="cov8" title="1">{
                service := mainline.NewIndexingService(addr, maxNeighbors, mainline.IndexingServiceEventHandlers{
                        OnResult: manager.onIndexingResult,
                }, bootstrappingNodes, filterNodes)
                manager.indexingServices = append(manager.indexingServices, service)
                service.Start()
        }</span>

        <span class="cov8" title="1">return manager</span>
}

func (m *Manager) Output() &lt;-chan Result <span class="cov0" title="0">{
        return m.output
}</span>

func (m *Manager) onIndexingResult(res mainline.IndexingResult) <span class="cov8" title="1">{
        select </span>{
        case m.output &lt;- res:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0">
                newChan := make(chan Result, len(m.output)+10)
                for oldRes := range m.output </span><span class="cov0" title="0">{
                        newChan &lt;- oldRes
                }</span>
                <span class="cov0" title="0">close(m.output)
                m.output = newChan
                m.output &lt;- res</span>
        }
}

func (m *Manager) Terminate() <span class="cov8" title="1">{
        for _, service := range m.indexingServices </span><span class="cov8" title="1">{
                service.Terminate()
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package main

import (
        "log"
        "os"
        "os/signal"
        "syscall"
        "time"

        "tgragnato.it/magnetico/v2/dht"
        "tgragnato.it/magnetico/v2/dht/mainline"
        "tgragnato.it/magnetico/v2/metadata"
        "tgragnato.it/magnetico/v2/opflags"
        "tgragnato.it/magnetico/v2/persistence"
        "tgragnato.it/magnetico/v2/stats"
        "tgragnato.it/magnetico/v2/web"
)

func main() <span class="cov0" title="0">{
        // opFlags is the "operational flags"
        opFlags := opflags.OpFlags{}
        if err := opFlags.Parse(); err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err.Error())
        }</span>

        // Handle Ctrl-C gracefully.
        <span class="cov0" title="0">interruptChan := make(chan os.Signal, 1)
        signal.Notify(interruptChan, os.Interrupt)

        database, err := persistence.MakeDatabase(opFlags.DatabaseURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Could not open the database %s. %s\n", opFlags.DatabaseURL, err.Error())
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err = database.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Could not close database! %s\n", err.Error())
                }</span>
        }()

        // Export the database to file if requested.
        <span class="cov0" title="0">if opFlags.Export != "" </span><span class="cov0" title="0">{
                err := persistence.MakeExport(database, opFlags.Export, interruptChan)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Could not export the database %s\n", err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Import the database from file if requested.
        <span class="cov0" title="0">if opFlags.Import != "" </span><span class="cov0" title="0">{
                err := persistence.MakeImport(database, opFlags.Import, interruptChan)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Could not import the database %s\n", err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Reload credentials when you receive SIGHUP
        <span class="cov0" title="0">sighupChan := make(chan os.Signal, 1)
        signal.Notify(sighupChan, syscall.SIGHUP)
        go func() </span><span class="cov0" title="0">{
                for range sighupChan </span><span class="cov0" title="0">{
                        if opFlags.Credentials == nil </span><span class="cov0" title="0">{
                                // Ignoring SIGHUP since no credential file was supplied
                                continue</span>
                        }

                        <span class="cov0" title="0">opFlags.Credentials = make(map[string][]byte)
                        if err := opFlags.LoadCred(); err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("couldn't load credentials %s\n", err.Error())
                        }</span>
                }
        }()

        <span class="cov0" title="0">if opFlags.PyroscopeURL != "" </span><span class="cov0" title="0">{
                profiler, err := stats.InitPyroscope(opFlags.PyroscopeURL)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("could not start pyroscope %s\n", err.Error())
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err := profiler.Stop(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Could not stop pyroscope! %s\n", err.Error())
                        }</span>
                }()
        }

        <span class="cov0" title="0">if opFlags.RunWeb </span><span class="cov0" title="0">{
                go web.StartWeb(opFlags.Addr, opFlags.Timeout, opFlags.Credentials, database)
        }</span>

        <span class="cov0" title="0">if !opFlags.RunDaemon </span><span class="cov0" title="0">{
                &lt;-interruptChan
                return
        }</span>

        <span class="cov0" title="0">mainline.DefaultThrottleRate = int(opFlags.MaxRPS)
        trawlingManager := dht.NewManager(
                opFlags.IndexerAddrs,
                opFlags.IndexerMaxNeighbors,
                opFlags.BootstrappingNodes,
                opFlags.FilterNodesIpNets,
        )
        metadataSink := metadata.NewSink(
                time.Duration(opFlags.LeechDeadline)*time.Second,
                int(opFlags.LeechMaxN),
                opFlags.FilterNodesIpNets,
        )

        // The Event Loop
        for stopped := false; !stopped; </span><span class="cov0" title="0">{
                select </span>{
                case result := &lt;-trawlingManager.Output():<span class="cov0" title="0">
                        infoHash := result.InfoHash()

                        exists, err := database.DoesTorrentExist(infoHash[:])
                        if err != nil </span><span class="cov0" title="0">{
                                go stats.GetInstance().IncDBError(false)
                        }</span> else<span class="cov0" title="0"> if !exists </span><span class="cov0" title="0">{
                                metadataSink.Sink(result)
                        }</span>

                case md := &lt;-metadataSink.Drain():<span class="cov0" title="0">
                        if err := database.AddNewTorrent(md.InfoHash, md.Name, md.Files); err != nil </span><span class="cov0" title="0">{
                                go stats.GetInstance().IncDBError(true)
                        }</span>

                case &lt;-interruptChan:<span class="cov0" title="0">
                        trawlingManager.Terminate()
                        stopped = true</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package merkle

import (
        "crypto/sha256"
        "hash"
)

func NewHash() *Hash <span class="cov8" title="1">{
        h := &amp;Hash{
                nextBlock: sha256.New(),
        }
        return h
}</span>

type Hash struct {
        blocks    [][sha256.Size]byte
        nextBlock hash.Hash
        // How many bytes have been written to nextBlock so far.
        nextBlockWritten int
}

func (h *Hash) remaining() int <span class="cov8" title="1">{
        return BlockSize - h.nextBlockWritten
}</span>

func (h *Hash) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        for len(p) &gt; 0 </span><span class="cov8" title="1">{
                var n1 int
                n1, err = h.nextBlock.Write(p[:min(len(p), h.remaining())])
                n += n1
                h.nextBlockWritten += n1
                p = p[n1:]
                if h.remaining() == 0 </span><span class="cov0" title="0">{
                        h.blocks = append(h.blocks, h.nextBlockSum())
                        h.nextBlock.Reset()
                        h.nextBlockWritten = 0
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (h *Hash) nextBlockSum() (sum [sha256.Size]byte) <span class="cov8" title="1">{
        copy(sum[:], h.nextBlock.Sum(sum[:0]))
        return
}</span>

func (h *Hash) curBlocks() [][sha256.Size]byte <span class="cov8" title="1">{
        blocks := h.blocks
        if h.nextBlockWritten != 0 </span><span class="cov8" title="1">{
                blocks = append(blocks, h.nextBlockSum())
        }</span>
        <span class="cov8" title="1">return blocks</span>
}

func (h *Hash) Sum(b []byte) []byte <span class="cov8" title="1">{
        sum := RootWithPadHash(h.curBlocks(), [sha256.Size]byte{})
        return append(b, sum[:]...)
}</span>

// Sums by extending with zero hashes for blocks missing to meet the given length. Necessary for
// piece layers hashes for file tail blocks that don't pad to the piece length.
func (h *Hash) SumMinLength(b []byte, length int) []byte <span class="cov8" title="1">{
        blocks := h.curBlocks()
        minBlocks := (length + BlockSize - 1) / BlockSize
        blocks = append(blocks, make([][sha256.Size]byte, minBlocks-len(blocks))...)
        sum := RootWithPadHash(blocks, [sha256.Size]byte{})
        return append(b, sum[:]...)
}</span>

// Reset resets the Hash to its initial state.
func (h *Hash) Reset() <span class="cov8" title="1">{
        h.blocks = h.blocks[:0]
        h.nextBlock.Reset()
        h.nextBlockWritten = 0
}</span>

// Size returns the size of the hash in bytes.
func (h *Hash) Size() int <span class="cov8" title="1">{
        return sha256.Size
}</span>

// BlockSize returns the block size of the hash.
func (h *Hash) BlockSize() int <span class="cov8" title="1">{
        return h.nextBlock.BlockSize()
}</span>

var _ hash.Hash = (*Hash)(nil)
</pre>
		
		<pre class="file" id="file14" style="display: none">package merkle

import (
        "crypto/sha256"
        "fmt"
        "math/bits"
)

// The leaf block size for BitTorrent v2 Merkle trees.
const BlockSize = 1 &lt;&lt; 14 // 16KiB

// Calculates the Merkle root of a list of hashes.
func Root(hashes [][sha256.Size]byte) [sha256.Size]byte <span class="cov8" title="1">{
        switch len(hashes) </span>{
        case 0:<span class="cov8" title="1">
                return sha256.Sum256(nil)</span>
        case 1:<span class="cov8" title="1">
                return hashes[0]</span>
        }
        <span class="cov8" title="1">numHashes := uint(len(hashes))
        if numHashes != RoundUpToPowerOfTwo(uint(len(hashes))) </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("expected power of two number of hashes, got %d", numHashes))</span>
        }
        <span class="cov8" title="1">var next [][sha256.Size]byte
        for i := 0; i &lt; len(hashes); i += 2 </span><span class="cov8" title="1">{
                left := hashes[i]
                right := hashes[i+1]
                h := sha256.Sum256(append(left[:], right[:]...))
                next = append(next, h)
        }</span>
        <span class="cov8" title="1">return Root(next)</span>
}

// Calculates the Merkle root of a list of hashes with a padding hash.
func RootWithPadHash(hashes [][sha256.Size]byte, padHash [sha256.Size]byte) [sha256.Size]byte <span class="cov8" title="1">{
        for uint(len(hashes)) &lt; RoundUpToPowerOfTwo(uint(len(hashes))) </span><span class="cov0" title="0">{
                hashes = append(hashes, padHash)
        }</span>
        <span class="cov8" title="1">return Root(hashes)</span>
}

// Converts a compact layer string into a slice of sha256 hashes.
func CompactLayerToSliceHashes(compactLayer string) (hashes [][sha256.Size]byte, err error) <span class="cov8" title="1">{
        hashes = make([][sha256.Size]byte, len(compactLayer)/sha256.Size)
        for i := range hashes </span><span class="cov8" title="1">{
                n := copy(hashes[i][:], compactLayer[i*sha256.Size:])
                if n != sha256.Size </span><span class="cov0" title="0">{
                        err = fmt.Errorf("compact layer has incomplete hash at index %d", i)
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// Returns the smallest power of two greater than or equal to the unsigned integer n.
func RoundUpToPowerOfTwo(n uint) (ret uint) <span class="cov8" title="1">{
        return 1 &lt;&lt; bits.Len(n-1)
}</span>

// Returns the smallest logarithm base two greater than or equal to the unsigned integer n.
func Log2RoundingUp(n uint) (ret uint) <span class="cov8" title="1">{
        if n == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return uint(bits.Len(n - 1))</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package btconn

import (
        "bytes"
        "errors"
        "io"
        "net"
        "time"
)

// The MIT License (MIT)
// Copyright (c) 2013 Cenk Alti

// Accept BitTorrent handshake from the connection. Handles encryption.
// Returns a new connection that is ready for sending/receiving BitTorrent protocol messages.
func Accept(
        conn net.Conn,
        handshakeTimeout time.Duration,
        getSKey func(sKeyHash [20]byte) (sKey []byte),
        hasInfoHash func([20]byte) bool,
        ourExtensions [8]byte, ourID [20]byte) (
        encConn net.Conn, cipher CryptoMethod, peerExtensions [8]byte, peerID [20]byte, infoHash [20]byte, err error) <span class="cov8" title="1">{

        if err = conn.SetDeadline(time.Now().Add(handshakeTimeout)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Try to do unencrypted handshake first.
        // If protocol string is not valid, try to do encrypted handshake.
        // rwConn returns the read bytes again that is read by handshake.Read1.
        <span class="cov8" title="1">var (
                buf    bytes.Buffer
                reader = io.TeeReader(conn, &amp;buf)
        )

        peerExtensions, infoHash, err = readHandshake1(reader)
        if err != nil &amp;&amp; getSKey != nil </span><span class="cov8" title="1">{
                conn = &amp;rwConn{readWriter{io.MultiReader(&amp;buf, conn), conn}, conn}
                mseConn := WrapConn(conn)
                err = mseConn.HandshakeIncoming(
                        getSKey,
                        func(provided CryptoMethod) (selected CryptoMethod) </span><span class="cov8" title="1">{
                                if provided&amp;RC4 != 0 </span><span class="cov8" title="1">{
                                        selected = RC4
                                }</span> else<span class="cov0" title="0"> if provided&amp;PlainText != 0 </span><span class="cov0" title="0">{
                                        selected = PlainText
                                        err = errors.New("encryption required but not used")
                                        return
                                }</span>
                                <span class="cov8" title="1">cipher = selected
                                return</span>
                        })
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">conn = mseConn
                peerExtensions, infoHash, err = readHandshake1(conn)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if !hasInfoHash(infoHash) </span><span class="cov0" title="0">{
                err = errors.New("info hash mismatch")
                return
        }</span>
        <span class="cov8" title="1">err = writeHandshake(conn, infoHash, ourID, ourExtensions)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">peerID, err = readHandshake2(conn)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if peerID == ourID </span><span class="cov0" title="0">{
                err = errors.New("peerID matches ourID")
                return
        }</span>
        <span class="cov8" title="1">encConn = conn
        return</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package btconn

import (
        "io"
        "net"
)

// The MIT License (MIT)
// Copyright (c) 2013 Cenk Alti

// Conn is a wrapper around net.Conn that does encryption/decryption on Read/Write methods.
type Conn struct {
        net.Conn
        *Stream
}

// WrapConn returns a new wrapper around conn. You must call HandshakeIncoming or
// HandshakeOutgoing methods before using Read/Write methods.
func WrapConn(conn net.Conn) *Conn <span class="cov8" title="1">{
        return &amp;Conn{
                Conn:   conn,
                Stream: NewStream(conn),
        }
}</span>

func (c *Conn) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        n, err = c.Stream.Read(p)
        return
}</span>

func (c *Conn) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        n, err = c.Stream.Write(p)
        return
}</span>

type readWriter struct {
        io.Reader
        io.Writer
}

type rwConn struct {
        rw io.ReadWriter
        net.Conn
}

func (c *rwConn) Read(p []byte) (n int, err error)  <span class="cov8" title="1">{ return c.rw.Read(p) }</span>
func (c *rwConn) Write(p []byte) (n int, err error) <span class="cov8" title="1">{ return c.rw.Write(p) }</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package btconn

import (
        "bytes"
        "context"
        "errors"
        "net"
        "time"
)

// The MIT License (MIT)
// Copyright (c) 2013 Cenk Alti

// Dial new connection to the address. Does the BitTorrent protocol handshake.
// Handles encryption. May try to connect again if encryption does not match with given setting.
// Returns a net.Conn that is ready for sending/receiving BitTorrent peer protocol messages.
func Dial(
        addr net.Addr,
        deadline time.Time,
        ourExtensions [8]byte,
        ih [20]byte,
        ourID [20]byte) (
        conn net.Conn, cipher CryptoMethod, peerExtensions [8]byte, peerID [20]byte, err error) <span class="cov8" title="1">{
        // First connection - Connecting to peer
        dialer := net.Dialer{Deadline: deadline}
        conn, err = dialer.DialContext(context.Background(), addr.Network(), addr.String())
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">defer func(conn net.Conn) </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        conn.Close()
                }</span>
        }(conn)

        // Try to use MPTCP - https://www.mptcp.dev/
        <span class="cov8" title="1">dialer.SetMultipathTCP(true)

        // Write first part of BitTorrent handshake to a buffer because we will use it in both encrypted and unencrypted handshake.
        out := bytes.NewBuffer(make([]byte, 0, 68))
        err = writeHandshake(out, ih, ourID, ourExtensions)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Handshake must be completed in allowed duration.
        <span class="cov8" title="1">if err = conn.SetDeadline(deadline); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">sKey := make([]byte, 20)
        copy(sKey, ih[:])

        provide := RC4

        // Try encryption handshake
        encConn := WrapConn(conn)
        cipher, err = encConn.HandshakeOutgoing(sKey, provide, out.Bytes())
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span> else<span class="cov8" title="1"> {
                conn = encConn
        }</span>

        // Read BT handshake
        <span class="cov8" title="1">var ihRead [20]byte
        peerExtensions, ihRead, err = readHandshake1(conn)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if ihRead != ih </span><span class="cov0" title="0">{
                err = errors.New("invalid infohash")
                return
        }</span>

        <span class="cov8" title="1">peerID, err = readHandshake2(conn)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if peerID == ourID </span><span class="cov0" title="0">{
                err = errors.New("peerID matches ourID")
                return
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package btconn

import (
        "encoding/binary"
        "errors"
        "io"
)

// The MIT License (MIT)
// Copyright (c) 2013 Cenk Alti

var pstr = [20]byte{19, 'B', 'i', 't', 'T', 'o', 'r', 'r', 'e', 'n', 't', ' ', 'p', 'r', 'o', 't', 'o', 'c', 'o', 'l'}

func writeHandshake(w io.Writer, ih [20]byte, id [20]byte, extensions [8]byte) error <span class="cov8" title="1">{
        h := struct {
                Pstr       [20]byte
                Extensions [8]byte
                InfoHash   [20]byte
                PeerID     [20]byte
        }{
                Pstr:       pstr,
                Extensions: extensions,
                InfoHash:   ih,
                PeerID:     id,
        }
        return binary.Write(w, binary.BigEndian, h)
}</span>

func readHandshake1(r io.Reader) (extensions [8]byte, ih [20]byte, err error) <span class="cov8" title="1">{
        _, err = io.ReadFull(r, ih[:])
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if ih != pstr </span><span class="cov8" title="1">{
                err = errors.New("invalid protocol")
                return
        }</span>
        <span class="cov8" title="1">_, err = io.ReadFull(r, extensions[:])
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">_, err = io.ReadFull(r, ih[:])
        return</span>
}

func readHandshake2(r io.Reader) (id [20]byte, err error) <span class="cov8" title="1">{
        _, err = io.ReadFull(r, id[:])
        return
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package btconn

import (
        "bytes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/rc4"
        "crypto/sha1"
        "encoding/binary"
        "encoding/hex"
        "errors"
        "fmt"
        "io"
        "math"
        "math/big"
        mrand "math/rand/v2"
)

// The MIT License (MIT)
// Copyright (c) 2013 Cenk Alti

var (
        pBytes = []byte{255, 255, 255, 255, 255, 255, 255, 255, 201, 15, 218, 162, 33, 104, 194, 52, 196, 198, 98, 139, 128, 220, 28, 209, 41, 2, 78, 8, 138, 103, 204, 116, 2, 11, 190, 166, 59, 19, 155, 34, 81, 74, 8, 121, 142, 52, 4, 221, 239, 149, 25, 179, 205, 58, 67, 27, 48, 43, 10, 109, 242, 95, 20, 55, 79, 225, 53, 109, 109, 81, 194, 69, 228, 133, 181, 118, 98, 94, 126, 198, 244, 76, 66, 233, 166, 58, 54, 33, 0, 0, 0, 0, 0, 9, 5, 99}
        p      = new(big.Int)
        g      = big.NewInt(2)
        vc     = make([]byte, 8)
)

func init() <span class="cov8" title="1">{ p.SetBytes(pBytes) }</span>

// CryptoMethod is 32-bit bitfield each bit representing a single crypto method.
type CryptoMethod uint32

// Crypto methods
const (
        PlainText CryptoMethod = 1 &lt;&lt; iota
        RC4
)

func (c CryptoMethod) String() string <span class="cov8" title="1">{
        switch c </span>{
        case PlainText:<span class="cov8" title="1">
                return "PlainText"</span>
        case RC4:<span class="cov8" title="1">
                return "RC4"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// Stream wraps a io.ReadWriter that automatically does encrypt/decrypt on read/write.
type Stream struct {
        raw io.ReadWriter
        r   *cipher.StreamReader
        w   *cipher.StreamWriter
        r2  io.Reader
}

// NewStream returns a new Stream. You must call HandshakeIncoming or
// HandshakeOutgoing methods before using Read/Write methods.
// If any error happens during the handshake underlying io.ReadWriter will be closed if it implements io.Closer.
func NewStream(rw io.ReadWriter) *Stream <span class="cov8" title="1">{ return &amp;Stream{raw: rw} }</span>

// Read from underlying io.ReadWriter, decrypt bytes and put into p.
func (s *Stream) Read(p []byte) (n int, err error) <span class="cov8" title="1">{ return s.r2.Read(p) }</span>

// Encrypt bytes in p and write into underlying io.ReadWriter.
func (s *Stream) Write(p []byte) (n int, err error) <span class="cov8" title="1">{ return s.w.Write(p) }</span>

// HandshakeOutgoing initiates MSE handshake for outgoing stream.
//
// sKey is stream identifier key. Same key must be used at the other side of the stream, otherwise handshake fails.
//
// cryptoProvide is a bitfield for specifying supported encryption methods.
//
// initialPayload is going to be sent along with handshake. It may be nil if you want to wait for the encryption negotiation.
func (s *Stream) HandshakeOutgoing(sKey []byte, cryptoProvide CryptoMethod, initialPayload []byte) (selected CryptoMethod, err error) <span class="cov8" title="1">{
        if cryptoProvide == 0 </span><span class="cov0" title="0">{
                err = errors.New("no crypto methods are provided")
                return
        }</span>
        <span class="cov8" title="1">if len(initialPayload) &gt; math.MaxUint16 </span><span class="cov0" title="0">{
                err = errors.New("initial payload is too big")
                return
        }</span>

        <span class="cov8" title="1">writeBuf := bytes.NewBuffer(make([]byte, 0, 96+512))

        Xa, Ya := keyPair()

        // Step 1 | A-&gt;B: Diffie Hellman Ya, PadA
        writeBuf.Write(bytesWithPad(Ya))
        padA, err := padRandom()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">writeBuf.Write(padA)
        _, err = writeBuf.WriteTo(s.raw)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Step 2 | B-&gt;A: Diffie Hellman Yb, PadB
        <span class="cov8" title="1">b := make([]byte, 96+512)
        firstRead, err := io.ReadAtLeast(s.raw, b, 96)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">Yb := new(big.Int)
        Yb.SetBytes(b[:96])
        S := Yb.Exp(Yb, Xa, p)
        err = s.initRC4("keyA", "keyB", S, sKey)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Step 3 | A-&gt;B: HASH('req1', S), HASH('req2', SKEY) xor HASH('req3', S), ENCRYPT(VC, crypto_provide, len(PadC), PadC, len(IA)), ENCRYPT(IA)
        <span class="cov8" title="1">hashS, hashSKey := hashes(S, sKey)
        padC, err := padZero()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">writeBuf.Write(hashS)
        writeBuf.Write(hashSKey)
        writeBuf.Write(vc)
        _ = binary.Write(writeBuf, binary.BigEndian, cryptoProvide)
        if len(padC) &gt; math.MaxUint16 </span><span class="cov0" title="0">{
                err = errors.New("padC is too big")
                return
        }</span>
        <span class="cov8" title="1">_ = binary.Write(writeBuf, binary.BigEndian, uint16(len(padC)))
        writeBuf.Write(padC)
        if len(initialPayload) &gt; math.MaxUint16 </span><span class="cov0" title="0">{
                err = errors.New("initial payload is too big")
                return
        }</span>
        <span class="cov8" title="1">_ = binary.Write(writeBuf, binary.BigEndian, uint16(len(initialPayload)))
        writeBuf.Write(initialPayload)
        encBytes := writeBuf.Bytes()[40:]
        s.w.S.XORKeyStream(encBytes, encBytes) // RC4
        _, err = writeBuf.WriteTo(s.raw)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Step 4 | B-&gt;A: ENCRYPT(VC, crypto_select, len(padD), padD), ENCRYPT2(Payload Stream)
        <span class="cov8" title="1">vcEnc := make([]byte, 8)
        s.r.S.XORKeyStream(vcEnc, vc)
        err = s.readSync(vcEnc, 616-firstRead)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">err = binary.Read(s.r, binary.BigEndian, &amp;selected)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if selected == 0 </span><span class="cov0" title="0">{
                err = errors.New("none of the provided methods are accepted")
                return
        }</span>
        <span class="cov8" title="1">if !isPowerOfTwo(uint32(selected)) </span><span class="cov0" title="0">{
                err = fmt.Errorf("invalid crypto selected: %d", selected)
                return
        }</span>
        <span class="cov8" title="1">if (selected &amp; cryptoProvide) == 0 </span><span class="cov0" title="0">{
                err = fmt.Errorf("selected crypto was not provided: %d", selected)
                return
        }</span>
        <span class="cov8" title="1">var lenPadD uint16
        err = binary.Read(s.r, binary.BigEndian, &amp;lenPadD)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">_, err = io.CopyN(io.Discard, s.r, int64(lenPadD))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">s.updateCipher(selected)
        s.r2 = s.r

        return</span>
        // Step 5 | A-&gt;B: ENCRYPT2(Payload Stream)
}

// HandshakeIncoming initiates MSE handshake for incoming stream.
//
// getSKey must return the correct stream identifier for given sKeyHash.
// sKeyHash can be calculated with mse.HashSKey function.
// If there is no matching sKeyHash in your application, you must return nil.
//
// cryptoSelect is a function that takes provided methods as a bitfield and returns the selected crypto method.
// Function may return zero value that means none of the provided methods are selected and handshake fails.
//
// payloadIn is a buffer for writing initial payload that is coming along with the handshake from the initiator of the handshake.
// If initial payload does not fit into payloadIn, handshake returns io.ErrShortBuffer.
//
// lenPayloadIn is length of the data read into payloadIn.
//
// processPayloadIn is an optional function that processes incoming initial payload and generate outgoing initial payload.
// If this function returns an error, handshake fails.
func (s *Stream) HandshakeIncoming(
        getSKey func(sKeyHash [20]byte) (sKey []byte),
        cryptoSelect func(provided CryptoMethod) (selected CryptoMethod)) (err error) <span class="cov8" title="1">{
        writeBuf := bytes.NewBuffer(make([]byte, 0, 96+512))

        Xb, Yb := keyPair()

        // Step 1 | A-&gt;B: Diffie Hellman Ya, PadA
        b := make([]byte, 96+512)
        firstRead, err := io.ReadAtLeast(s.raw, b, 96)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">Ya := new(big.Int)
        Ya.SetBytes(b[:96])
        S := Ya.Exp(Ya, Xb, p)

        // Step 2 | B-&gt;A: Diffie Hellman Yb, PadB
        writeBuf.Write(bytesWithPad(Yb))
        padB, err := padRandom()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">writeBuf.Write(padB)
        _, err = writeBuf.WriteTo(s.raw)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Step 3 | A-&gt;B: HASH('req1', S), HASH('req2', SKEY) xor HASH('req3', S), ENCRYPT(VC, crypto_provide, len(PadC), PadC, len(IA)), ENCRYPT(IA)
        <span class="cov8" title="1">req1 := hashInt("req1", S)
        err = s.readSync(req1, 628-firstRead)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">var hashRead [20]byte
        _, err = io.ReadFull(s.raw, hashRead[:])
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">req3 := hashInt("req3", S)
        for i := 0; i &lt; sha1.Size; i++ </span><span class="cov8" title="1">{
                hashRead[i] ^= req3[i]
        }</span>
        <span class="cov8" title="1">sKey := getSKey(hashRead)
        if sKey == nil </span><span class="cov0" title="0">{
                err = errors.New("invalid SKEY hash")
                return
        }</span>
        <span class="cov8" title="1">err = s.initRC4("keyB", "keyA", S, sKey)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">vcRead := make([]byte, 8)
        _, err = io.ReadFull(s.r, vcRead)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(vcRead, vc) </span><span class="cov0" title="0">{
                err = fmt.Errorf("invalid VC: %s", hex.EncodeToString(vcRead))
                return
        }</span>
        <span class="cov8" title="1">var cryptoProvide CryptoMethod
        err = binary.Read(s.r, binary.BigEndian, &amp;cryptoProvide)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if cryptoProvide == 0 </span><span class="cov0" title="0">{
                err = errors.New("no crypto methods are provided")
                return
        }</span>
        <span class="cov8" title="1">selected := cryptoSelect(cryptoProvide)
        if selected == 0 </span><span class="cov0" title="0">{
                err = errors.New("none of the provided methods are accepted")
                return
        }</span>
        <span class="cov8" title="1">if !isPowerOfTwo(uint32(selected)) </span><span class="cov0" title="0">{
                err = fmt.Errorf("invalid crypto selected: %d", selected)
                return
        }</span>
        <span class="cov8" title="1">if (selected &amp; cryptoProvide) == 0 </span><span class="cov0" title="0">{
                err = fmt.Errorf("selected crypto is not provided: %d", selected)
                return
        }</span>
        <span class="cov8" title="1">var lenPadC uint16
        err = binary.Read(s.r, binary.BigEndian, &amp;lenPadC)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">_, err = io.CopyN(io.Discard, s.r, int64(lenPadC))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">var lenIA uint16
        err = binary.Read(s.r, binary.BigEndian, &amp;lenIA)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">IA := bytes.NewBuffer(make([]byte, 0, lenIA))
        _, err = io.CopyN(IA, s.r, int64(lenIA))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Step 4 | B-&gt;A: ENCRYPT(VC, crypto_select, len(padD), padD), ENCRYPT2(Payload Stream)
        <span class="cov8" title="1">writeBuf.Write(vc)
        _ = binary.Write(writeBuf, binary.BigEndian, selected)
        padD, err := padZero()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if len(padD) &gt; math.MaxUint16 </span><span class="cov0" title="0">{
                err = errors.New("padD is too big")
                return
        }</span>
        <span class="cov8" title="1">_ = binary.Write(writeBuf, binary.BigEndian, uint16(len(padD)))
        writeBuf.Write(padD)

        _, err = writeBuf.WriteTo(s.w)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">s.updateCipher(selected)
        s.r2 = io.MultiReader(IA, s.r)
        return</span>
        // Step 5 | A-&gt;B: ENCRYPT2(Payload Stream)
}

func (s *Stream) initRC4(encKey, decKey string, S *big.Int, sKey []byte) error <span class="cov8" title="1">{ //nolint:gocritic
        cipherEnc, err := rc4.NewCipher(rc4Key(encKey, S, sKey))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">cipherDec, err := rc4.NewCipher(rc4Key(decKey, S, sKey))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var buf [1024]byte
        discard := buf[:]
        cipherEnc.XORKeyStream(discard, discard)
        cipherDec.XORKeyStream(discard, discard)
        s.w = &amp;cipher.StreamWriter{S: cipherEnc, W: s.raw}
        s.r = &amp;cipher.StreamReader{S: cipherDec, R: s.raw}
        return nil</span>
}

func (s *Stream) updateCipher(selected CryptoMethod) <span class="cov8" title="1">{
        switch selected </span>{
        case RC4:<span class="cov8" title="1"></span>
        case PlainText:<span class="cov0" title="0">
                s.r = &amp;cipher.StreamReader{S: plainTextCipher{}, R: s.raw}
                s.w = &amp;cipher.StreamWriter{S: plainTextCipher{}, W: s.raw}</span>
        }
}

func (s *Stream) readSync(key []byte, max int) error <span class="cov8" title="1">{
        var readBuf bytes.Buffer
        if _, err := io.CopyN(&amp;readBuf, s.raw, int64(len(key))); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">max -= len(key)
        for </span><span class="cov8" title="1">{
                if bytes.Equal(readBuf.Bytes(), key) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">if max &lt;= 0 </span><span class="cov0" title="0">{
                        return errors.New("sync point is not found")
                }</span>
                <span class="cov0" title="0">if _, err := io.CopyN(&amp;readBuf, s.raw, 1); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">max--
                if _, err := io.CopyN(io.Discard, &amp;readBuf, 1); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
}

func privateKey() *big.Int <span class="cov8" title="1">{
        b := make([]byte, 20)
        _, err := rand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                for i := 0; i &lt; 20; i++ </span><span class="cov0" title="0">{
                        b[i] = byte(mrand.IntN(256))
                }</span>
        }
        <span class="cov8" title="1">var n big.Int
        return n.SetBytes(b)</span>
}

func publicKey(private *big.Int) *big.Int <span class="cov8" title="1">{
        var n big.Int
        return n.Exp(g, private, p)
}</span>

func keyPair() (private, public *big.Int) <span class="cov8" title="1">{
        private = privateKey()
        public = publicKey(private)
        return
}</span>

// bytesWithPad adds padding in front of the bytes to fill 96 bytes.
func bytesWithPad(key *big.Int) []byte <span class="cov8" title="1">{
        b := key.Bytes()
        pad := 96 - len(b)
        if pad &gt; 0 </span><span class="cov0" title="0">{
                b = make([]byte, 96)
                copy(b[pad:], key.Bytes())
        }</span>
        <span class="cov8" title="1">return b</span>
}

func isPowerOfTwo(x uint32) bool <span class="cov8" title="1">{ return (x != 0) &amp;&amp; ((x &amp; (x - 1)) == 0) }</span>

func hashes(S *big.Int, sKey []byte) (hashS, hashSKey []byte) <span class="cov8" title="1">{ // nolint:gocritic
        req1 := hashInt("req1", S)
        req2 := HashSKey(sKey)
        req3 := hashInt("req3", S)
        for i := 0; i &lt; sha1.Size; i++ </span><span class="cov8" title="1">{
                req3[i] ^= req2[i]
        }</span>
        <span class="cov8" title="1">return req1, req3</span>
}

func hashInt(prefix string, i *big.Int) []byte <span class="cov8" title="1">{
        h := sha1.New()
        _, _ = h.Write([]byte(prefix))
        _, _ = h.Write(bytesWithPad(i))
        return h.Sum(nil)
}</span>

// HashSKey returns the hash of key.
func HashSKey(key []byte) [20]byte <span class="cov8" title="1">{
        var sum [20]byte
        h := sha1.New()
        _, _ = h.Write([]byte("req2"))
        _, _ = h.Write(key)
        copy(sum[:], h.Sum(nil))
        return sum
}</span>

func rc4Key(prefix string, S *big.Int, sKey []byte) []byte <span class="cov8" title="1">{ // nolint:gocritic
        h := sha1.New()
        _, _ = h.Write([]byte(prefix))
        _, _ = h.Write(bytesWithPad(S))
        _, _ = h.Write(sKey)
        return h.Sum(nil)
}</span>

func padRandom() ([]byte, error) <span class="cov8" title="1">{
        b, err := padZero()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_, err = rand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(b); i++ </span><span class="cov0" title="0">{
                        b[i] = byte(mrand.IntN(256))
                }</span>
        }
        <span class="cov8" title="1">return b, nil</span>
}

func padZero() ([]byte, error) <span class="cov8" title="1">{
        padLen, err := rand.Int(rand.Reader, big.NewInt(512))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return make([]byte, int(padLen.Int64())), nil</span>
}

type plainTextCipher struct{}

func (plainTextCipher) XORKeyStream(dst, src []byte) <span class="cov0" title="0">{ copy(dst, src) }</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package metadata

import (
        "net"
        "sync"
)

type infoHashes struct {
        sync.RWMutex
        infoHashes  map[[20]byte][]net.TCPAddr
        maxNLeeches int
        filterPeers []net.IPNet
}

func newInfoHashes(maxNLeeches int, filterPeers []net.IPNet) *infoHashes <span class="cov8" title="1">{
        return &amp;infoHashes{
                infoHashes:  make(map[[20]byte][]net.TCPAddr),
                maxNLeeches: maxNLeeches,
                filterPeers: filterPeers,
        }
}</span>

func (ih *infoHashes) isAllowed(peer net.TCPAddr) bool <span class="cov8" title="1">{
        if len(ih.filterPeers) &gt; 0 </span><span class="cov8" title="1">{
                for _, filterPeer := range ih.filterPeers </span><span class="cov8" title="1">{
                        if filterPeer.Contains(peer.IP) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }

                <span class="cov8" title="1">return false</span>
        }

        <span class="cov8" title="1">if !peer.IP.IsGlobalUnicast() || peer.IP.IsPrivate() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if peer.Port &lt; 1024 || peer.Port &gt; 65535 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (ih *infoHashes) push(infoHash [20]byte, peerAddresses []net.TCPAddr) <span class="cov8" title="1">{
        if len(peerAddresses) &lt;= 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">ih.Lock()
        defer ih.Unlock()

        for _, addr := range peerAddresses </span><span class="cov8" title="1">{
                if !ih.isAllowed(addr) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if len(ih.infoHashes[infoHash]) &gt;= ih.maxNLeeches </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">if checkDuplicate(ih.infoHashes[infoHash], addr) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">ih.infoHashes[infoHash] = append(ih.infoHashes[infoHash], addr)</span>
        }
}

func checkDuplicate(peerAddresses []net.TCPAddr, addr net.TCPAddr) bool <span class="cov8" title="1">{
        for _, existingAddr := range peerAddresses </span><span class="cov8" title="1">{
                if existingAddr.IP.Equal(addr.IP) &amp;&amp;
                        existingAddr.Port == addr.Port </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (ih *infoHashes) pop(infoHash [20]byte) *net.TCPAddr <span class="cov8" title="1">{
        ih.Lock()
        defer ih.Unlock()

        peerAddresses, exists := ih.infoHashes[infoHash]
        if !exists </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if len(peerAddresses) &lt;= 0 </span><span class="cov0" title="0">{
                go ih.flush(infoHash)
                return nil
        }</span>

        <span class="cov8" title="1">peerAddress := peerAddresses[0]
        ih.infoHashes[infoHash] = peerAddresses[1:]
        return &amp;peerAddress</span>
}

func (ih *infoHashes) flush(infoHash [20]byte) <span class="cov8" title="1">{
        ih.Lock()
        defer ih.Unlock()
        delete(ih.infoHashes, infoHash)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package metadata

import (
        "bytes"
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "math"
        "net"
        "time"

        "tgragnato.it/magnetico/v2/bencode"
        "tgragnato.it/magnetico/v2/metadata/btconn"
        "tgragnato.it/magnetico/v2/stats"
)

const MAX_METADATA_SIZE = 10 * 1024 * 1024

type rootDict struct {
        M            mDict `bencode:"m"`
        MetadataSize int   `bencode:"metadata_size"`
}

type mDict struct {
        UTMetadata int `bencode:"ut_metadata"`
}

type extDict struct {
        MsgType int `bencode:"msg_type"`
        Piece   int `bencode:"piece"`
}

type Leech struct {
        infoHash [20]byte
        peerAddr *net.TCPAddr
        ev       LeechEventHandlers

        conn     net.Conn
        clientID [20]byte

        ut_metadata                    uint8
        metadataReceived, metadataSize uint
        metadata                       []byte

        connClosed bool
}

type LeechEventHandlers struct {
        OnSuccess func(Metadata)        // must be supplied. args: metadata
        OnError   func([20]byte, error) // must be supplied. args: infohash, error
}

func NewLeech(infoHash [20]byte, peerAddr *net.TCPAddr, clientID []byte, ev LeechEventHandlers) *Leech <span class="cov8" title="1">{
        l := new(Leech)
        l.infoHash = infoHash
        l.peerAddr = peerAddr
        copy(l.clientID[:], clientID)
        l.ev = ev

        return l
}</span>

func (l *Leech) writeAll(b []byte) error <span class="cov8" title="1">{
        for len(b) != 0 </span><span class="cov8" title="1">{
                n, err := l.conn.Write(b)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">b = b[n:]</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (l *Leech) readExactly(n uint) ([]byte, error) <span class="cov8" title="1">{
        b := make([]byte, n)
        _, err := io.ReadFull(l.conn, b)
        return b, err
}</span>

func (l *Leech) closeConn() <span class="cov8" title="1">{
        if l.connClosed </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if err := l.conn.Close(); err != nil </span><span class="cov0" title="0">{
                panic("couldn't close leech connection! " + err.Error())</span>
        }

        <span class="cov8" title="1">l.connClosed = true</span>
}

func (l *Leech) OnError(err error) <span class="cov8" title="1">{
        l.ev.OnError(l.infoHash, err)
}</span>

func (l *Leech) doExHandshake() error <span class="cov8" title="1">{
        err := l.writeAll([]byte("\x00\x00\x00\x1a\x14\x00d1:md11:ut_metadatai1eee"))
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("writeAll lHandshake " + err.Error())
        }</span>

        <span class="cov8" title="1">rExMessage, err := l.readExMessage()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("readExMessage " + err.Error())
        }</span>

        // Extension Handshake has the Extension Message ID = 0x00
        <span class="cov8" title="1">if rExMessage[1] != 0 </span><span class="cov8" title="1">{
                return errors.New("first extension message is not an extension handshake")
        }</span>

        <span class="cov8" title="1">rRootDict := new(rootDict)
        err = bencode.Unmarshal(rExMessage[2:], rRootDict)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("unmarshal rExMessage " + err.Error())
        }</span>

        <span class="cov8" title="1">if rRootDict.MetadataSize &lt;= 0 || rRootDict.MetadataSize &gt;= MAX_METADATA_SIZE </span><span class="cov8" title="1">{
                return fmt.Errorf("metadata too big or its size is less than or equal zero")
        }</span>

        <span class="cov8" title="1">if rRootDict.M.UTMetadata &lt;= 0 || rRootDict.M.UTMetadata &gt;= 255 </span><span class="cov0" title="0">{
                return fmt.Errorf("ut_metadata is not an uint8")
        }</span>

        <span class="cov8" title="1">l.ut_metadata = uint8(rRootDict.M.UTMetadata) // Save the ut_metadata code the remote peer uses
        l.metadataSize = uint(rRootDict.MetadataSize)
        l.metadata = make([]byte, l.metadataSize)

        return nil</span>
}

func (l *Leech) requestAllPieces() error <span class="cov8" title="1">{
        // Request all the pieces of metadata
        nPieces := int(math.Ceil(float64(l.metadataSize) / math.Pow(2, 14)))
        if nPieces == 0 </span><span class="cov8" title="1">{
                return errors.New("metadataSize is zero")
        }</span>

        <span class="cov8" title="1">for piece := 0; piece &lt; nPieces; piece++ </span><span class="cov8" title="1">{
                // __request_metadata_piece(piece)
                // ...............................
                extDictDump, err := bencode.Marshal(extDict{
                        MsgType: 0,
                        Piece:   piece,
                })
                if err != nil </span><span class="cov0" title="0">{ // ASSERT
                        return errors.New("marshal extDict " + err.Error())
                }</span>

                <span class="cov8" title="1">err = l.writeAll([]byte(fmt.Sprintf(
                        "%s\x14%s%s",
                        toBigEndian(uint(2+len(extDictDump)), 4),
                        toBigEndian(uint(l.ut_metadata), 1),
                        extDictDump,
                )))
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("writeAll piece request " + err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// readMessage returns a BitTorrent message, sans the first 4 bytes indicating its length.
func (l *Leech) readMessage() ([]byte, error) <span class="cov8" title="1">{
        rLengthB, err := l.readExactly(4)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("readExactly rLengthB " + err.Error())
        }</span>

        <span class="cov8" title="1">rLength := uint(binary.BigEndian.Uint32(rLengthB))

        // Some malicious/faulty peers say that they are sending a very long
        // message, and hence causing us to run out of memory.
        // This is a crude check that does not let it happen (i.e. boundary can probably be
        // tightened a lot more.)
        if rLength &gt; MAX_METADATA_SIZE </span><span class="cov8" title="1">{
                return nil, errors.New("message is longer than max allowed metadata size")
        }</span>

        <span class="cov8" title="1">rMessage, err := l.readExactly(rLength)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("readExactly rMessage " + err.Error())
        }</span>

        <span class="cov8" title="1">return rMessage, nil</span>
}

// readExMessage returns an *extension* message, sans the first 4 bytes indicating its length.
//
// It will IGNORE all non-extension messages!
func (l *Leech) readExMessage() ([]byte, error) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                rMessage, err := l.readMessage()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, errors.New("readMessage " + err.Error())
                }</span>

                // Every extension message has at least 2 bytes.
                <span class="cov8" title="1">if len(rMessage) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // We are interested only in extension messages, whose first byte is always 20
                <span class="cov8" title="1">if rMessage[0] == 20 </span><span class="cov8" title="1">{
                        return rMessage, nil
                }</span>
        }
}

// readUmMessage returns an ut_metadata extension message, sans the first 4 bytes indicating its
// length.
//
// It will IGNORE all non-"ut_metadata extension" messages!
func (l *Leech) readUmMessage() ([]byte, error) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                rExMessage, err := l.readExMessage()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, errors.New("readExMessage " + err.Error())
                }</span>

                <span class="cov8" title="1">if rExMessage[1] == 0x01 </span><span class="cov8" title="1">{
                        return rExMessage, nil
                }</span>
        }
}

func (l *Leech) Do(deadline time.Time) <span class="cov8" title="1">{
        conn, _, peerExtensions, _, err := btconn.Dial(
                l.peerAddr,
                deadline,
                [8]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x01},
                l.infoHash,
                l.clientID,
        )
        if err != nil </span><span class="cov8" title="1">{
                l.OnError(errors.New("btconn.Dial " + err.Error()))
                return
        }</span>

        <span class="cov0" title="0">l.conn = conn
        defer l.closeConn()
        go stats.GetInstance().IncLeech(peerExtensions)

        err = l.doExHandshake()
        if err != nil </span><span class="cov0" title="0">{
                l.OnError(errors.New("doExHandshake " + err.Error()))
                return
        }</span>

        <span class="cov0" title="0">err = l.requestAllPieces()
        if err != nil </span><span class="cov0" title="0">{
                l.OnError(errors.New("requestAllPieces " + err.Error()))
                return
        }</span>

        <span class="cov0" title="0">for l.metadataReceived &lt; l.metadataSize </span><span class="cov0" title="0">{
                rUmMessage, err := l.readUmMessage()
                if err != nil </span><span class="cov0" title="0">{
                        l.OnError(errors.New("readUmMessage " + err.Error()))
                        return
                }</span>

                // Run TestDecoder() function in leech_test.go in case you have any doubts.
                <span class="cov0" title="0">rMessageBuf := bytes.NewBuffer(rUmMessage[2:])
                rExtDict := new(extDict)
                err = bencode.NewDecoder(rMessageBuf).Decode(rExtDict)
                if err != nil </span><span class="cov0" title="0">{
                        l.OnError(errors.New("could not decode ext msg in the loop " + err.Error()))
                        return
                }</span>

                <span class="cov0" title="0">if rExtDict.MsgType == 2 </span><span class="cov0" title="0">{ // reject
                        l.OnError(fmt.Errorf("remote peer rejected sending metadata"))
                        return
                }</span>

                <span class="cov0" title="0">if rExtDict.MsgType == 1 </span><span class="cov0" title="0">{ // data
                        // Get the unread bytes!
                        metadataPiece := rMessageBuf.Bytes()

                        // BEP 9 explicitly states:
                        //   &gt; If the piece is the last piece of the metadata, it may be less than 16kiB. If
                        //   &gt; it is not the last piece of the metadata, it MUST be 16kiB.
                        //
                        // Hence...
                        //   ... if the length of @metadataPiece is more than 16kiB, we err.
                        if len(metadataPiece) &gt; 16*1024 </span><span class="cov0" title="0">{
                                l.OnError(fmt.Errorf("metadataPiece &gt; 16kiB"))
                                return
                        }</span>

                        <span class="cov0" title="0">piece := rExtDict.Piece
                        // metadata[piece * 2**14: piece * 2**14 + len(metadataPiece)] = metadataPiece is how it'd be done in Python
                        copy(l.metadata[piece*int(math.Pow(2, 14)):piece*int(math.Pow(2, 14))+len(metadataPiece)], metadataPiece)
                        l.metadataReceived += uint(len(metadataPiece))

                        // ... if the length of @metadataPiece is less than 16kiB AND metadata is NOT
                        // complete then we err.
                        if len(metadataPiece) &lt; 16*1024 &amp;&amp; l.metadataReceived != l.metadataSize </span><span class="cov0" title="0">{
                                l.OnError(fmt.Errorf("metadataPiece &lt; 16 kiB but incomplete"))
                                return
                        }</span>

                        <span class="cov0" title="0">if l.metadataReceived &gt; l.metadataSize </span><span class="cov0" title="0">{
                                l.OnError(fmt.Errorf("metadataReceived &gt; metadataSize"))
                                return
                        }</span>
                }
        }

        // We are done with the transfer, close socket as soon as possible (i.e. NOW)
        // Avoid hitting "too many open files" error
        <span class="cov0" title="0">l.closeConn()

        extracted, err := extractMetadata(l.metadata, l.infoHash, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                l.OnError(err)
                return
        }</span>

        <span class="cov0" title="0">l.ev.OnSuccess(*extracted)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package metadata

import (
        "net"
        "time"

        "tgragnato.it/magnetico/v2/dht"
        "tgragnato.it/magnetico/v2/persistence"
)

const (
        // PeerIDLength The peer_id is exactly 20 bytes (characters) long.
        // https://wiki.theory.org/BitTorrentSpecification#peer_id
        PeerIDLength = 20
        // PeerPrefix Azureus-style
        PeerPrefix = "-UT3600-"
)

type Metadata struct {
        InfoHash []byte
        // Name should be thought of "Title" of the torrent. For single-file torrents, it is the name
        // of the file, and for multi-file torrents, it is the name of the root directory.
        Name         string
        TotalSize    uint64
        DiscoveredOn int64
        // Files must be populated for both single-file and multi-file torrents!
        Files []persistence.File
}

type Sink struct {
        PeerID   []byte
        deadline time.Duration
        drain    chan Metadata

        incomingInfoHashes *infoHashes

        terminated  bool
        termination chan interface{}
}

func NewSink(deadline time.Duration, maxNLeeches int, filterNodes []net.IPNet) *Sink <span class="cov8" title="1">{
        ms := new(Sink)

        ms.PeerID = randomID()
        ms.deadline = deadline
        ms.drain = make(chan Metadata, 10)
        ms.incomingInfoHashes = newInfoHashes(maxNLeeches, filterNodes)
        ms.termination = make(chan interface{})

        return ms
}</span>

func (ms *Sink) Sink(res dht.Result) <span class="cov8" title="1">{
        if ms.terminated </span><span class="cov0" title="0">{
                panic("Trying to Sink() an already closed Sink!")</span>
        }

        <span class="cov8" title="1">infoHash := res.InfoHash()
        peerAddrs := res.PeerAddrs()
        if len(peerAddrs) &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">go ms.leech(infoHash, peerAddrs[1:], peerAddrs[0])</span>
}

func (ms *Sink) leech(infoHash [20]byte, peerAddrs []net.TCPAddr, firstPeer net.TCPAddr) <span class="cov8" title="1">{
        ms.incomingInfoHashes.push(infoHash, peerAddrs)
        NewLeech(infoHash, &amp;firstPeer, ms.PeerID, LeechEventHandlers{
                OnSuccess: ms.flush,
                OnError:   ms.onLeechError,
        }).Do(time.Now().Add(ms.deadline))
}</span>

func (ms *Sink) Drain() &lt;-chan Metadata <span class="cov8" title="1">{
        if ms.terminated </span><span class="cov8" title="1">{
                panic("Trying to Drain() an already closed Sink!")</span>
        }
        <span class="cov0" title="0">return ms.drain</span>
}

func (ms *Sink) Terminate() <span class="cov8" title="1">{
        ms.terminated = true
        close(ms.termination)
        close(ms.drain)
}</span>

func (ms *Sink) flush(result Metadata) <span class="cov8" title="1">{
        if ms.terminated </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">ms.drain &lt;- result

        var infoHash [20]byte
        copy(infoHash[:], result.InfoHash)
        go ms.incomingInfoHashes.flush(infoHash)</span>
}

func (ms *Sink) onLeechError(infoHash [20]byte, err error) <span class="cov8" title="1">{
        if peer := ms.incomingInfoHashes.pop(infoHash); peer != nil </span><span class="cov0" title="0">{
                go NewLeech(infoHash, peer, ms.PeerID, LeechEventHandlers{
                        OnSuccess: ms.flush,
                        OnError:   ms.onLeechError,
                }).Do(time.Now().Add(ms.deadline))
        }</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package metadata

import (
        "bytes"
        "crypto/rand"
        "crypto/sha1"
        "encoding/binary"
        "errors"
        mrand "math/rand/v2"
        "time"

        "tgragnato.it/magnetico/v2/bencode"
        "tgragnato.it/magnetico/v2/metainfo"
        "tgragnato.it/magnetico/v2/persistence"
)

func totalSize(files []persistence.File) (uint64, error) <span class="cov8" title="1">{
        var totalSize uint64
        if len(files) == 0 </span><span class="cov8" title="1">{
                return 0, errors.New("no files would be persisted")
        }</span>

        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                if file.Size &lt; 0 </span><span class="cov8" title="1">{
                        return 0, errors.New("file size less than zero")
                }</span>

                <span class="cov8" title="1">totalSize += uint64(file.Size)</span>
        }
        <span class="cov8" title="1">return totalSize, nil</span>
}

// Unmarshal the metainfo from the metadata
func unmarshalMetainfo(metadata []byte) (info *metainfo.Info, err error) <span class="cov8" title="1">{
        info = new(metainfo.Info)
        err = bencode.Unmarshal(metadata, info)
        if err != nil </span><span class="cov8" title="1">{
                info = nil
                return
        }</span>

        <span class="cov8" title="1">err = validateInfo(info)
        if err != nil </span><span class="cov0" title="0">{
                info = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// Check the info dictionary
func validateInfo(info *metainfo.Info) error <span class="cov8" title="1">{
        if len(info.Pieces)%20 != 0 </span><span class="cov8" title="1">{
                return errors.New("pieces has invalid length")
        }</span>
        <span class="cov8" title="1">if info.PieceLength == 0 </span><span class="cov8" title="1">{
                return errors.New("zero piece length")
        }</span>
        <span class="cov8" title="1">if int((info.TotalLength()+info.PieceLength-1)/info.PieceLength) != info.NumPieces() </span><span class="cov8" title="1">{
                return errors.New("piece count and file lengths are at odds")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Extract the files from the metainfo
func extractFiles(info *metainfo.Info) (files []persistence.File) <span class="cov8" title="1">{
        if len(info.Files) == 0 </span><span class="cov8" title="1">{
                // Single file
                files = append(files, persistence.File{
                        Size: info.Length,
                        Path: info.Name,
                })
                return
        }</span>

        // Multiple files
        <span class="cov8" title="1">for _, file := range info.Files </span><span class="cov8" title="1">{
                files = append(files, persistence.File{
                        Size: file.Length,
                        Path: file.DisplayPath(info),
                })
        }</span>
        <span class="cov8" title="1">return</span>
}

// extractMetadata extracts metadata from a byte array and verifies it with an infohash.
// Returns a pointer to a Metadata structure and an error, if any.
//
// Parameters:
// - meta: a byte array containing the metadata to be extracted.
// - infohash: a 20-byte array representing the infohash for verification.
// - discovery: a timestamp representing the discovery time of the metadata.
//
// Returns:
// - A pointer to a Metadata structure containing the extracted and verified metadata.
// - An error if any validation or check does not complete with success.
func extractMetadata(meta []byte, infohash [20]byte, discovery time.Time) (*Metadata, error) <span class="cov8" title="1">{
        sha1Sum := sha1.Sum(meta)
        if !bytes.Equal(sha1Sum[:], infohash[:]) </span><span class="cov0" title="0">{
                return nil, errors.New("infohash mismatch")
        }</span>

        <span class="cov8" title="1">info, err := unmarshalMetainfo(meta)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">files := extractFiles(info)
        totalSize, err := totalSize(files)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Metadata{
                InfoHash:     infohash[:],
                Name:         info.Name,
                TotalSize:    totalSize,
                DiscoveredOn: discovery.Unix(),
                Files:        files,
        }, nil</span>
}

// randomID generates a random peer ID with a predefined prefix.
// Returns a byte slice representing the generated peer ID.
func randomID() []byte <span class="cov8" title="1">{
        prefix := []byte(PeerPrefix)
        var rando []byte

        peace := PeerIDLength - len(prefix)
        for i := peace; i &gt; 0; i-- </span><span class="cov8" title="1">{
                rando = append(rando, randomDigit())
        }</span>

        <span class="cov8" title="1">return append(prefix, rando...)</span>
}

// randomDigit as byte (ASCII code range 0-9 digits)
func randomDigit() byte <span class="cov8" title="1">{
        b := make([]byte, 1)
        _, err := rand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                b[0] = byte(mrand.IntN(256))
        }</span>
        <span class="cov8" title="1">return (b[0] % 10) + '0'</span>
}

func toBigEndian(i uint, n int) []byte <span class="cov8" title="1">{
        if n &lt; 0 </span><span class="cov8" title="1">{
                // n must be positive
                return nil
        }</span>

        <span class="cov8" title="1">b := make([]byte, n)
        switch n </span>{
        case 1:<span class="cov8" title="1">
                b = []byte{byte(i)}</span>

        case 2:<span class="cov8" title="1">
                binary.BigEndian.PutUint16(b, uint16(i))</span>

        case 4:<span class="cov8" title="1">
                binary.BigEndian.PutUint32(b, uint32(i))</span>

        default:<span class="cov8" title="1">
                // n must be 1, 2, or 4
                return nil</span>
        }

        <span class="cov8" title="1">if len(b) != n </span><span class="cov0" title="0">{
                // postcondition failed: len(b) != n in intToBigEndian (i, n)
                return nil
        }</span>

        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package metainfo

import (
        "slices"
)

type AnnounceList [][]string

func (al AnnounceList) Clone() AnnounceList <span class="cov0" title="0">{
        return slices.Clone(al)
}</span>

// Whether the AnnounceList should be preferred over a single URL announce.
func (al AnnounceList) OverridesAnnounce(announce string) bool <span class="cov8" title="1">{
        for _, tier := range al </span><span class="cov8" title="1">{
                for _, url := range tier </span><span class="cov8" title="1">{
                        if url != "" || announce == "" </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func (al AnnounceList) DistinctValues() (ret []string) <span class="cov8" title="1">{
        seen := make(map[string]struct{})
        for _, tier := range al </span><span class="cov8" title="1">{
                for _, v := range tier </span><span class="cov8" title="1">{
                        if _, ok := seen[v]; !ok </span><span class="cov8" title="1">{
                                seen[v] = struct{}{}
                                ret = append(ret, v)
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package metainfo

import (
        "fmt"
        "reflect"

        "tgragnato.it/magnetico/v2/merkle"
)

func ValidatePieceLayers(
        pieceLayers map[string]string,
        fileTree *FileTree,
        pieceLength int64,
) (err error) <span class="cov8" title="1">{
        fileTree.Walk(nil, func(path []string, ft *FileTree) </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">if ft.IsDir() </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">piecesRoot := ft.PiecesRootAsByteArray()
                if reflect.DeepEqual(piecesRoot, [32]byte{}) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">filePieceLayers, ok := pieceLayers[string(piecesRoot[:])]
                if !ok </span><span class="cov8" title="1">{
                        // BEP 52: "For each file in the file tree that is larger than the piece size it
                        // contains one string value.". The reference torrent creator in
                        // https://blog.libtorrent.org/2020/09/bittorrent-v2/ also has this. If a file is equal
                        // to or smaller than the piece length, we can just use the pieces root instead of the
                        // piece layer hash.
                        if ft.File.Length &gt; pieceLength </span><span class="cov0" title="0">{
                                err = fmt.Errorf("no piece layers for file %q", path)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }
                <span class="cov8" title="1">var layerHashes [][32]byte
                layerHashes, err = merkle.CompactLayerToSliceHashes(filePieceLayers)
                root := merkle.RootWithPadHash(layerHashes, HashForPiecePad(pieceLength))
                if root != piecesRoot </span><span class="cov0" title="0">{
                        err = fmt.Errorf("file %q: expected hash %x got %x", path, piecesRoot, root)
                        return
                }</span>
        })
        <span class="cov8" title="1">return</span>
}

// Returns the padding hash for the hash layer corresponding to a piece. It can't be zero because
// that's the bottom-most layer (the hashes for the smallest blocks).
func HashForPiecePad(pieceLength int64) (hash [32]byte) <span class="cov8" title="1">{
        // This should be a power of two, and probably checked elsewhere.
        blocksPerPiece := pieceLength / (1 &lt;&lt; 14)
        blockHashes := make([][32]byte, blocksPerPiece)
        return merkle.Root(blockHashes)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package metainfo

import (
        "errors"
        "iter"
        "maps"
        "slices"

        "tgragnato.it/magnetico/v2/bencode"
        infohash_v2 "tgragnato.it/magnetico/v2/types/infohash-v2"
)

const FileTreePropertiesKey = ""

type FileTreeFile struct {
        Length     int64  `bencode:"length"`
        PiecesRoot string `bencode:"pieces root"`
}

// The fields here don't need bencode tags as the marshalling is done manually.
type FileTree struct {
        File FileTreeFile
        Dir  map[string]FileTree
}

func (ft *FileTree) UnmarshalBencode(bytes []byte) (err error) <span class="cov8" title="1">{
        var dir map[string]bencode.Bytes
        err = bencode.Unmarshal(bytes, &amp;dir)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if propBytes, ok := dir[""]; ok </span><span class="cov8" title="1">{
                err = bencode.Unmarshal(propBytes, &amp;ft.File)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">delete(dir, "")
        ft.Dir = make(map[string]FileTree, len(dir))
        for key, bytes := range dir </span><span class="cov8" title="1">{
                var sub FileTree
                err = sub.UnmarshalBencode(bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">ft.Dir[key] = sub</span>
        }
        <span class="cov8" title="1">return</span>
}

var _ bencode.Unmarshaler = (*FileTree)(nil)

func (ft *FileTree) MarshalBencode() (bytes []byte, err error) <span class="cov8" title="1">{
        if ft.IsDir() </span><span class="cov8" title="1">{
                dir := make(map[string]bencode.Bytes, len(ft.Dir))
                for _, key := range ft.orderedKeys() </span><span class="cov8" title="1">{
                        if key == FileTreePropertiesKey </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">sub, ok := ft.Dir[key]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, errors.New("missing subfile")
                        }</span>
                        <span class="cov8" title="1">subBytes, err := sub.MarshalBencode()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">dir[key] = subBytes</span>
                }
                <span class="cov8" title="1">return bencode.Marshal(dir)</span>
        } else<span class="cov8" title="1"> {
                fileBytes, err := bencode.Marshal(ft.File)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">res := map[string]bencode.Bytes{
                        "": fileBytes,
                }
                return bencode.Marshal(res)</span>
        }
}

var _ bencode.Marshaler = (*FileTree)(nil)

func (ft *FileTree) NumEntries() (num int) <span class="cov8" title="1">{
        num = len(ft.Dir)
        if _, ok := ft.Dir[FileTreePropertiesKey]; ok </span><span class="cov0" title="0">{
                num--
        }</span>
        <span class="cov8" title="1">return</span>
}

func (ft *FileTree) IsDir() bool <span class="cov8" title="1">{
        return ft.NumEntries() != 0
}</span>

func (ft *FileTree) orderedKeys() []string <span class="cov8" title="1">{
        return slices.Sorted(maps.Keys(ft.Dir))
}</span>

func (ft *FileTree) upvertedFiles(pieceLength int64) iter.Seq[FileInfo] <span class="cov0" title="0">{
        var offset int64
        return ft.upvertedFilesInner(pieceLength, nil, &amp;offset)
}</span>

func (ft *FileTree) upvertedFilesInner(
        pieceLength int64,
        path []string,
        offset *int64,
) iter.Seq[FileInfo] <span class="cov8" title="1">{
        return func(yield func(FileInfo) bool) </span><span class="cov8" title="1">{
                if ft.IsDir() </span><span class="cov8" title="1">{
                        for _, key := range ft.orderedKeys() </span><span class="cov8" title="1">{
                                if key == FileTreePropertiesKey </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">sub, ok := ft.Dir[key]
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov8" title="1">for fi := range sub.upvertedFilesInner(pieceLength, append(path, key), offset) </span><span class="cov8" title="1">{
                                        if !yield(fi) </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                }
                        }
                } else<span class="cov8" title="1"> {
                        yield(FileInfo{
                                Length: ft.File.Length,
                                Path:   append([]string(nil), path...),
                                // BEP 52 requires paths be UTF-8 if possible.
                                PathUtf8:      append([]string(nil), path...),
                                PiecesRoot:    ft.PiecesRootAsByteArray(),
                                TorrentOffset: *offset,
                        })
                        // v2 files are piece aligned. This bumps up the offset to the next piece boundary.
                        *offset += (ft.File.Length + pieceLength - 1) / pieceLength * pieceLength
                }</span>
        }
}

func (ft *FileTree) Walk(path []string, f func(path []string, ft *FileTree)) <span class="cov8" title="1">{
        f(path, ft)
        for key, sub := range ft.Dir </span><span class="cov8" title="1">{
                if key == FileTreePropertiesKey </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">sub.Walk(append(path, key), f)</span>
        }
}

func (ft *FileTree) PiecesRootAsByteArray() (ret infohash_v2.T) <span class="cov8" title="1">{
        if ft.File.PiecesRoot == "" </span><span class="cov0" title="0">{
                return [32]byte{}
        }</span>
        <span class="cov8" title="1">n := copy(ret[:], ft.File.PiecesRoot)
        if n != 32 </span><span class="cov8" title="1">{
                // Must be 32 bytes for meta version 2 and non-empty files. See BEP 52.
                return [32]byte{}
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package metainfo

import (
        "strings"

        infohash_v2 "tgragnato.it/magnetico/v2/types/infohash-v2"
)

// Information specific to a single file inside the MetaInfo structure.
type FileInfo struct {
        // BEP3. With BEP 47 this can be optional, but we have no way to describe that without breaking
        // the API.
        Length int64    `bencode:"length"`
        Path   []string `bencode:"path"` // BEP3
        // Unofficial extension by BiglyBT? https://github.com/BiglySoftware/BiglyBT/issues/1274.
        PathUtf8 []string `bencode:"path.utf-8,omitempty" json:"path.utf-8,omitempty"`

        ExtendedFileAttrs `json:",omitempty"`

        // BEP 52. This isn't encoded in a v1 FileInfo, but is exposed here for APIs that expect to deal
        // v1 files.
        PiecesRoot    infohash_v2.T `bencode:"-"`
        TorrentOffset int64         `bencode:"-"`
}

func (fi *FileInfo) DisplayPath(info *Info) string <span class="cov8" title="1">{
        if info.IsDir() </span><span class="cov8" title="1">{
                return strings.Join(fi.BestPath(), "/")
        }</span> else<span class="cov8" title="1"> {
                return info.BestName()
        }</span>
}

func (fi *FileInfo) BestPath() []string <span class="cov8" title="1">{
        if len(fi.PathUtf8) != 0 </span><span class="cov8" title="1">{
                return fi.PathUtf8
        }</span>
        <span class="cov8" title="1">return fi.Path</span>
}

func (fi *FileInfo) BeginPieceIndex(pieceLength int64) int <span class="cov0" title="0">{
        if pieceLength == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return int(fi.TorrentOffset / pieceLength)</span>
}

func (fi *FileInfo) EndPieceIndex(pieceLength int64) int <span class="cov0" title="0">{
        if pieceLength == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return int((fi.TorrentOffset + fi.Length + pieceLength - 1) / pieceLength)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package metainfo

import (
        "errors"
        "fmt"
        "io"
        "iter"
        "os"
        "path/filepath"
        "slices"
        "sort"
        "strings"
)

// The info dictionary. See BEP 3 and BEP 52.
type Info struct {
        PieceLength int64 `bencode:"piece length"` // BEP3
        // BEP 3. This can be omitted because isn't needed in non-hybrid v2 infos. See BEP 52.
        Pieces   []byte `bencode:"pieces,omitempty"`
        Name     string `bencode:"name"` // BEP3
        NameUtf8 string `bencode:"name.utf-8,omitempty"`
        Length   int64  `bencode:"length,omitempty"` // BEP3, mutually exclusive with Files
        ExtendedFileAttrs
        Private *bool `bencode:"private,omitempty"` // BEP27
        // TODO: Document this field.
        Source string     `bencode:"source,omitempty"`
        Files  []FileInfo `bencode:"files,omitempty"` // BEP3, mutually exclusive with Length

        // BEP 52 (BitTorrent v2)
        MetaVersion int64    `bencode:"meta version,omitempty"`
        FileTree    FileTree `bencode:"file tree,omitempty"`
}

// The Info.Name field is "advisory". For multi-file torrents it's usually a suggested directory
// name. There are situations where we don't want a directory (like using the contents of a torrent
// as the immediate contents of a directory), or the name is invalid. Transmission will inject the
// name of the torrent file if it doesn't like the name, resulting in a different infohash
// (https://github.com/transmission/transmission/issues/1775). To work around these situations, we
// will use a sentinel name for compatibility with Transmission and to signal to our own client that
// we intended to have no directory name. By exposing it in the API we can check for references to
// this behaviour within this implementation.
const NoName = "-"

// This is a helper that sets Files and Pieces from a root path and its children.
func (info *Info) BuildFromFilePath(root string) (err error) <span class="cov8" title="1">{
        info.Name = func() string </span><span class="cov8" title="1">{
                b := filepath.Base(root)
                switch b </span>{
                case ".", "..", string(filepath.Separator):<span class="cov0" title="0">
                        return NoName</span>
                default:<span class="cov8" title="1">
                        return b</span>
                }
        }()
        <span class="cov8" title="1">info.Files = nil
        err = filepath.Walk(root, func(path string, fi os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if fi.IsDir() </span><span class="cov8" title="1">{
                        // Directories are implicit in torrent files.
                        return nil
                }</span> else<span class="cov8" title="1"> if path == root </span><span class="cov0" title="0">{
                        // The root is a file.
                        info.Length = fi.Size()
                        return nil
                }</span>
                <span class="cov8" title="1">relPath, err := filepath.Rel(root, path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting relative path: %s", err)
                }</span>
                <span class="cov8" title="1">info.Files = append(info.Files, FileInfo{
                        Path:   strings.Split(relPath, string(filepath.Separator)),
                        Length: fi.Size(),
                })
                return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">sort.Slice(info.Files, func(i, j int) bool </span><span class="cov8" title="1">{
                return strings.Join(info.Files[i].BestPath(), "/") &lt; strings.Join(info.Files[j].BestPath(), "/")
        }</span>)
        <span class="cov8" title="1">if info.PieceLength == 0 </span><span class="cov0" title="0">{
                info.PieceLength = ChoosePieceLength(info.TotalLength())
        }</span>
        <span class="cov8" title="1">err = info.GeneratePieces(func(fi FileInfo) (io.ReadCloser, error) </span><span class="cov8" title="1">{
                return os.Open(filepath.Join(root, strings.Join(fi.BestPath(), string(filepath.Separator))))
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("error generating pieces: %s", err)
        }</span>
        <span class="cov8" title="1">return</span>
}

// Concatenates all the files in the torrent into w. open is a function that
// gets at the contents of the given file.
func (info *Info) writeFiles(w io.Writer, open func(fi FileInfo) (io.ReadCloser, error)) error <span class="cov8" title="1">{
        for _, fi := range info.UpvertedFiles() </span><span class="cov8" title="1">{
                r, err := open(fi)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error opening %v: %s", fi, err)
                }</span>
                <span class="cov8" title="1">wn, err := io.CopyN(w, r, fi.Length)
                r.Close()
                if wn != fi.Length </span><span class="cov0" title="0">{
                        return fmt.Errorf("error copying %v: %s", fi, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Sets Pieces (the block of piece hashes in the Info) by using the passed
// function to get at the torrent data.
func (info *Info) GeneratePieces(open func(fi FileInfo) (io.ReadCloser, error)) (err error) <span class="cov8" title="1">{
        if info.PieceLength == 0 </span><span class="cov0" title="0">{
                return errors.New("piece length must be non-zero")
        }</span>
        <span class="cov8" title="1">pr, pw := io.Pipe()
        go func() </span><span class="cov8" title="1">{
                err := info.writeFiles(pw, open)
                pw.CloseWithError(err)
        }</span>()
        <span class="cov8" title="1">defer pr.Close()
        info.Pieces, err = GeneratePieces(pr, info.PieceLength, nil)
        return</span>
}

func (info *Info) TotalLength() (ret int64) <span class="cov8" title="1">{
        for _, fi := range info.UpvertedFiles() </span><span class="cov8" title="1">{
                ret += fi.Length
        }</span>
        <span class="cov8" title="1">return</span>
}

func (info *Info) NumPieces() (num int) <span class="cov8" title="1">{
        if info.HasV2() </span><span class="cov8" title="1">{
                info.FileTree.Walk(nil, func(path []string, ft *FileTree) </span><span class="cov8" title="1">{
                        num += int((ft.File.Length + info.PieceLength - 1) / info.PieceLength)
                }</span>)
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">return len(info.Pieces) / 20</span>
}

// Whether all files share the same top-level directory name. If they don't, Info.Name is usually used.
func (info *Info) IsDir() bool <span class="cov8" title="1">{
        if info.HasV2() </span><span class="cov0" title="0">{
                return info.FileTree.IsDir()
        }</span>
        // I wonder if we should check for the existence of Info.Length here instead.
        <span class="cov8" title="1">return len(info.Files) != 0</span>
}

// The files field, converted up from the old single-file in the parent info dict if necessary. This
// is a helper to avoid having to conditionally handle single and multi-file torrent infos.
func (info *Info) UpvertedFiles() (files []FileInfo) <span class="cov8" title="1">{
        return slices.Collect(info.UpvertedFilesIter())
}</span>

// The files field, converted up from the old single-file in the parent info dict if necessary. This
// is a helper to avoid having to conditionally handle single and multi-file torrent infos.
func (info *Info) UpvertedFilesIter() iter.Seq[FileInfo] <span class="cov8" title="1">{
        if info.HasV2() </span><span class="cov0" title="0">{
                return info.FileTree.upvertedFiles(info.PieceLength)
        }</span>
        <span class="cov8" title="1">return info.UpvertedV1Files()</span>
}

// UpvertedFiles but specific to the files listed in the v1 info fields. This will include padding
// files for example that wouldn't appear in v2 file trees.
func (info *Info) UpvertedV1Files() iter.Seq[FileInfo] <span class="cov8" title="1">{
        return func(yield func(FileInfo) bool) </span><span class="cov8" title="1">{
                if len(info.Files) == 0 </span><span class="cov0" title="0">{
                        yield(FileInfo{
                                Length: info.Length,
                                // Callers should determine that Info.Name is the basename, and
                                // thus a regular file.
                                Path: nil,
                        })
                }</span>
                <span class="cov8" title="1">var offset int64
                for _, fi := range info.Files </span><span class="cov8" title="1">{
                        fi.TorrentOffset = offset
                        offset += fi.Length
                        if !yield(fi) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

func (info *Info) Piece(index int) Piece <span class="cov0" title="0">{
        return Piece{info, index}
}</span>

func (info *Info) BestName() string <span class="cov8" title="1">{
        if info.NameUtf8 != "" </span><span class="cov0" title="0">{
                return info.NameUtf8
        }</span>
        <span class="cov8" title="1">return info.Name</span>
}

// Whether the Info can be used as a v2 info dict, including having a V2 infohash.
func (info *Info) HasV2() bool <span class="cov8" title="1">{
        return info.MetaVersion == 2
}</span>

func (info *Info) HasV1() bool <span class="cov8" title="1">{
        // See Upgrade Path in BEP 52.
        return info.MetaVersion == 0 || info.MetaVersion == 1 || info.Files != nil || info.Length != 0 || len(info.Pieces) != 0
}</span>

func (info *Info) FilesArePieceAligned() bool <span class="cov0" title="0">{
        return info.HasV2()
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package metainfo

import (
        "encoding/hex"
        "errors"
        "fmt"
        "net/url"
        "reflect"
        "strings"

        "github.com/multiformats/go-multihash"
        "tgragnato.it/magnetico/v2/types/infohash"
        infohash_v2 "tgragnato.it/magnetico/v2/types/infohash-v2"
)

// Magnet link components.
type MagnetV2 struct {
        InfoHash    infohash.T // Expected in this implementation
        V2InfoHash  infohash_v2.T
        Trackers    []string   // "tr" values
        DisplayName string     // "dn" value, if not empty
        Params      url.Values // All other values, such as "x.pe", "as", "xs" etc.
}

const (
        btmhPrefix = "urn:btmh:"
)

func (m MagnetV2) String() string <span class="cov8" title="1">{
        // Deep-copy m.Params
        vs := make(url.Values, len(m.Params)+len(m.Trackers)+2)
        for k, v := range m.Params </span><span class="cov8" title="1">{
                vs[k] = append([]string(nil), v...)
        }</span>

        <span class="cov8" title="1">for _, tr := range m.Trackers </span><span class="cov8" title="1">{
                vs.Add("tr", tr)
        }</span>
        <span class="cov8" title="1">if m.DisplayName != "" </span><span class="cov8" title="1">{
                vs.Add("dn", m.DisplayName)
        }</span>

        // Transmission and Deluge both expect "urn:btih:" to be unescaped. Deluge wants it to be at the
        // start of the magnet link. The InfoHash field is expected to be BitTorrent in this
        // implementation.
        <span class="cov8" title="1">u := url.URL{
                Scheme: "magnet",
        }
        var queryParts []string

        if !reflect.DeepEqual(m.InfoHash, infohash.T{}) </span><span class="cov0" title="0">{
                queryParts = append(queryParts, "xt="+btihPrefix+m.InfoHash.HexString())
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(m.V2InfoHash, infohash_v2.T{}) </span><span class="cov0" title="0">{
                queryParts = append(
                        queryParts,
                        "xt="+btmhPrefix+infohash_v2.ToMultihash(m.V2InfoHash).HexString(),
                )
        }</span>
        <span class="cov8" title="1">if rem := vs.Encode(); rem != "" </span><span class="cov8" title="1">{
                queryParts = append(queryParts, rem)
        }</span>
        <span class="cov8" title="1">u.RawQuery = strings.Join(queryParts, "&amp;")
        return u.String()</span>
}

// ParseMagnetUri parses Magnet-formatted URIs into a Magnet instance
func ParseMagnetV2Uri(uri string) (m MagnetV2, err error) <span class="cov8" title="1">{
        u, err := url.Parse(uri)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("error parsing uri: %w", err)
                return
        }</span>
        <span class="cov8" title="1">if u.Scheme != "magnet" </span><span class="cov0" title="0">{
                err = fmt.Errorf("unexpected scheme %q", u.Scheme)
                return
        }</span>
        <span class="cov8" title="1">q := u.Query()
        for _, xt := range q["xt"] </span><span class="cov8" title="1">{
                if hashStr, found := strings.CutPrefix(xt, btihPrefix); found </span><span class="cov8" title="1">{
                        if !reflect.DeepEqual(m.InfoHash, infohash.T{}) </span><span class="cov0" title="0">{
                                err = errors.New("more than one infohash found in magnet link")
                                return
                        }</span>
                        <span class="cov8" title="1">m.InfoHash, err = parseEncodedV1Infohash(hashStr)
                        if err != nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("error parsing infohash %q: %w", hashStr, err)
                                return
                        }</span>
                } else<span class="cov8" title="1"> if hashStr, found := strings.CutPrefix(xt, btmhPrefix); found </span><span class="cov8" title="1">{
                        if !reflect.DeepEqual(m.V2InfoHash, infohash_v2.T{}) </span><span class="cov0" title="0">{
                                err = errors.New("more than one infohash found in magnet link")
                                return
                        }</span>
                        <span class="cov8" title="1">m.V2InfoHash, err = parseV2Infohash(hashStr)
                        if err != nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("error parsing infohash %q: %w", hashStr, err)
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        lazyAddParam(&amp;m.Params, "xt", xt)
                }</span>
        }
        <span class="cov8" title="1">q.Del("xt")
        m.DisplayName = popFirstValue(q, "dn")
        m.Trackers = q["tr"]
        q.Del("tr")
        // Add everything we haven't consumed.
        copyParams(&amp;m.Params, q)
        return</span>
}

func lazyAddParam(vs *url.Values, k, v string) <span class="cov8" title="1">{
        if *vs == nil </span><span class="cov8" title="1">{
                *vs = make(url.Values)
        }</span>
        <span class="cov8" title="1">vs.Add(k, v)</span>
}

func copyParams(dest *url.Values, src url.Values) <span class="cov8" title="1">{
        for k, vs := range src </span><span class="cov8" title="1">{
                for _, v := range vs </span><span class="cov8" title="1">{
                        lazyAddParam(dest, k, v)
                }</span>
        }
}

func parseV2Infohash(encoded string) (ih infohash_v2.T, err error) <span class="cov8" title="1">{
        b, err := hex.DecodeString(encoded)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">mh, err := multihash.Decode(b)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if mh.Code != multihash.SHA2_256 || mh.Length != infohash_v2.Size || len(mh.Digest) != infohash_v2.Size </span><span class="cov0" title="0">{
                err = errors.New("bad multihash")
                return
        }</span>
        <span class="cov8" title="1">n := copy(ih[:], mh.Digest)
        if n != infohash_v2.Size </span><span class="cov0" title="0">{
                return infohash_v2.T{}, errors.New("decoded xt length != 32")
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package metainfo

import (
        "encoding/base32"
        "encoding/hex"
        "errors"
        "fmt"
        "net/url"
        "strings"

        "tgragnato.it/magnetico/v2/types/infohash"
)

// Magnet link components.
type Magnet struct {
        InfoHash    infohash.T // Expected in this implementation
        Trackers    []string   // "tr" values
        DisplayName string     // "dn" value, if not empty
        Params      url.Values // All other values, such as "x.pe", "as", "xs" etc.
}

const btihPrefix = "urn:btih:"

func (m Magnet) String() string <span class="cov8" title="1">{
        // Deep-copy m.Params
        vs := make(url.Values, len(m.Params)+len(m.Trackers)+2)
        for k, v := range m.Params </span><span class="cov8" title="1">{
                vs[k] = append([]string(nil), v...)
        }</span>

        <span class="cov8" title="1">for _, tr := range m.Trackers </span><span class="cov8" title="1">{
                vs.Add("tr", tr)
        }</span>
        <span class="cov8" title="1">if m.DisplayName != "" </span><span class="cov8" title="1">{
                vs.Add("dn", m.DisplayName)
        }</span>

        // Transmission and Deluge both expect "urn:btih:" to be unescaped. Deluge wants it to be at the
        // start of the magnet link. The InfoHash field is expected to be BitTorrent in this
        // implementation.
        <span class="cov8" title="1">u := url.URL{
                Scheme:   "magnet",
                RawQuery: "xt=" + btihPrefix + m.InfoHash.HexString(),
        }
        if len(vs) != 0 </span><span class="cov8" title="1">{
                u.RawQuery += "&amp;" + vs.Encode()
        }</span>
        <span class="cov8" title="1">return u.String()</span>
}

// Deprecated: Use ParseMagnetUri.
var ParseMagnetURI = ParseMagnetUri

// ParseMagnetUri parses Magnet-formatted URIs into a Magnet instance
func ParseMagnetUri(uri string) (m Magnet, err error) <span class="cov8" title="1">{
        u, err := url.Parse(uri)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("error parsing uri: %w", err)
                return
        }</span>
        <span class="cov8" title="1">if u.Scheme != "magnet" </span><span class="cov8" title="1">{
                err = fmt.Errorf("unexpected scheme %q", u.Scheme)
                return
        }</span>
        <span class="cov8" title="1">q := u.Query()
        gotInfohash := false
        for _, xt := range q["xt"] </span><span class="cov8" title="1">{
                if gotInfohash </span><span class="cov8" title="1">{
                        lazyAddParam(&amp;m.Params, "xt", xt)
                        continue</span>
                }
                <span class="cov8" title="1">encoded, found := strings.CutPrefix(xt, btihPrefix)
                if !found </span><span class="cov8" title="1">{
                        lazyAddParam(&amp;m.Params, "xt", xt)
                        continue</span>
                }
                <span class="cov8" title="1">m.InfoHash, err = parseEncodedV1Infohash(encoded)
                if err != nil </span><span class="cov8" title="1">{
                        err = fmt.Errorf("error parsing v1 infohash %q: %w", xt, err)
                        return
                }</span>
                <span class="cov8" title="1">gotInfohash = true</span>
        }
        <span class="cov8" title="1">if !gotInfohash </span><span class="cov8" title="1">{
                err = errors.New("missing v1 infohash")
                return
        }</span>
        <span class="cov8" title="1">q.Del("xt")
        m.DisplayName = popFirstValue(q, "dn")
        m.Trackers = q["tr"]
        q.Del("tr")
        copyParams(&amp;m.Params, q)
        return</span>
}

func parseEncodedV1Infohash(encoded string) (ih infohash.T, err error) <span class="cov8" title="1">{
        decode := func() func(dst, src []byte) (int, error) </span><span class="cov8" title="1">{
                switch len(encoded) </span>{
                case 40:<span class="cov8" title="1">
                        return hex.Decode</span>
                case 32:<span class="cov8" title="1">
                        return base32.StdEncoding.Decode</span>
                }
                <span class="cov8" title="1">return nil</span>
        }()
        <span class="cov8" title="1">if decode == nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("unhandled xt parameter encoding (encoded length %d)", len(encoded))
                return
        }</span>
        <span class="cov8" title="1">n, err := decode(ih[:], []byte(encoded))
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("error decoding xt: %w", err)
                return
        }</span>
        <span class="cov8" title="1">if n != 20 </span><span class="cov0" title="0">{
                return infohash.T{}, errors.New("decoded xt length != 20")
        }</span>
        <span class="cov8" title="1">return</span>
}

func popFirstValue(vs url.Values, key string) string <span class="cov8" title="1">{
        sl := vs[key]
        switch len(sl) </span>{
        case 0:<span class="cov8" title="1">
                return ""</span>
        case 1:<span class="cov8" title="1">
                vs.Del(key)
                return sl[0]</span>
        default:<span class="cov0" title="0">
                vs[key] = sl[1:]
                return sl[0]</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package metainfo

import (
        "bufio"
        "fmt"
        "io"
        "net/url"
        "os"
        "time"

        "tgragnato.it/magnetico/v2/bencode"
        "tgragnato.it/magnetico/v2/types/infohash"
        infohash_v2 "tgragnato.it/magnetico/v2/types/infohash-v2"
)

// Also known as a torrent file.
type MetaInfo struct {
        InfoBytes    bencode.Bytes `bencode:"info,omitempty"`                                                        // BEP 3
        Announce     string        `bencode:"announce,omitempty" mapstructure:",omitempty"`                          // BEP 3
        AnnounceList AnnounceList  `bencode:"announce-list,omitempty"`                                               // BEP 12
        Nodes        []Node        `bencode:"nodes,omitempty,ignore_unmarshal_type_error" mapstructure:",omitempty"` // BEP 5
        // Where's this specified? Mentioned at
        // https://wiki.theory.org/index.php/BitTorrentSpecification: (optional) the creation time of
        // the torrent, in standard UNIX epoch format (integer, seconds since 1-Jan-1970 00:00:00 UTC)
        CreationDate int64   `bencode:"creation date,omitempty,ignore_unmarshal_type_error"`
        Comment      string  `bencode:"comment,omitempty"`
        CreatedBy    string  `bencode:"created by,omitempty"`
        Encoding     string  `bencode:"encoding,omitempty" mapstructure:",omitempty"` // BEP 54
        UrlList      UrlList `bencode:"url-list,omitempty"`                           // BEP 19 WebSeeds
        // BEP 52 (BitTorrent v2): Keys are file merkle roots ("pieces root"s), and the values are the
        // concatenated hashes of the merkle tree layer that corresponds to the piece length.
        PieceLayers map[string]string `bencode:"piece layers,omitempty" mapstructure:",omitempty"`
}

// Load a MetaInfo from an io.Reader. Returns a non-nil error in case of failure.
func Load(r io.Reader) (*MetaInfo, error) <span class="cov8" title="1">{
        var mi MetaInfo
        d := bencode.NewDecoder(r)
        err := d.Decode(&amp;mi)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = d.ReadEOF()
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("error after decoding metainfo: %w", err)
        }</span>
        <span class="cov8" title="1">return &amp;mi, err</span>
}

// Convenience function for loading a MetaInfo from a file.
func LoadFromFile(filename string) (*MetaInfo, error) <span class="cov8" title="1">{
        f, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer f.Close()
        var buf bufio.Reader
        buf.Reset(f)
        return Load(&amp;buf)</span>
}

func (mi *MetaInfo) UnmarshalInfo() (info Info, err error) <span class="cov8" title="1">{
        err = bencode.Unmarshal(mi.InfoBytes, &amp;info)
        return
}</span>

func (mi *MetaInfo) HashInfoBytes() (infoHash infohash.T) <span class="cov8" title="1">{
        return infohash.HashBytes(mi.InfoBytes)
}</span>

// Encode to bencoded form.
func (mi *MetaInfo) Write(w io.Writer) error <span class="cov8" title="1">{
        return bencode.NewEncoder(w).Encode(mi)
}</span>

// Set good default values in preparation for creating a new MetaInfo file.
func (mi *MetaInfo) SetDefaults() <span class="cov0" title="0">{
        mi.CreatedBy = "tgragnato.it/magnetico/v2"
        mi.CreationDate = time.Now().Unix()
}</span>

// Deprecated: Use MagnetV2. Creates a Magnet from a MetaInfo. Optional infohash and parsed info can
// be provided.
func (mi MetaInfo) Magnet(infoHash *infohash.T, info *Info) (m Magnet) <span class="cov8" title="1">{
        m.Trackers = append(m.Trackers, mi.UpvertedAnnounceList().DistinctValues()...)
        if info != nil </span><span class="cov8" title="1">{
                m.DisplayName = info.BestName()
        }</span>
        <span class="cov8" title="1">if infoHash != nil </span><span class="cov0" title="0">{
                m.InfoHash = *infoHash
        }</span> else<span class="cov8" title="1"> {
                m.InfoHash = mi.HashInfoBytes()
        }</span>
        <span class="cov8" title="1">m.Params = make(url.Values)
        m.Params["ws"] = mi.UrlList
        return</span>
}

// Creates a MagnetV2 from a MetaInfo. This supports v1, hybrid, and v2 magnet links.
func (mi *MetaInfo) MagnetV2() (m MagnetV2, err error) <span class="cov0" title="0">{
        m.Trackers = append(m.Trackers, mi.UpvertedAnnounceList().DistinctValues()...)
        info, err := mi.UnmarshalInfo()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">m.DisplayName = info.BestName()
        if info.HasV1() </span><span class="cov0" title="0">{
                m.InfoHash = mi.HashInfoBytes()
        }</span>
        <span class="cov0" title="0">if info.HasV2() </span><span class="cov0" title="0">{
                m.V2InfoHash = infohash_v2.HashBytes(mi.InfoBytes)
        }</span>
        <span class="cov0" title="0">m.Params = make(url.Values)
        m.Params["ws"] = mi.UrlList
        return</span>
}

// Returns the announce-list converted from the old single announce field if necessary.
func (mi *MetaInfo) UpvertedAnnounceList() AnnounceList <span class="cov8" title="1">{
        if mi.AnnounceList.OverridesAnnounce(mi.Announce) </span><span class="cov8" title="1">{
                return mi.AnnounceList
        }</span>
        <span class="cov0" title="0">if mi.Announce != "" </span><span class="cov0" title="0">{
                return [][]string{{mi.Announce}}
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package metainfo

import (
        "fmt"
        "net"
        "strconv"

        "tgragnato.it/magnetico/v2/bencode"
)

type Node string

var _ bencode.Unmarshaler = (*Node)(nil)

func (n *Node) UnmarshalBencode(b []byte) (err error) <span class="cov8" title="1">{
        var iface interface{}
        err = bencode.Unmarshal(b, &amp;iface)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">switch v := iface.(type) </span>{
        case string:<span class="cov8" title="1">
                *n = Node(v)</span>
        case []interface{}:<span class="cov8" title="1">
                func() </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                r := recover()
                                if r != nil </span><span class="cov0" title="0">{
                                        err = r.(error)
                                }</span>
                        }()
                        <span class="cov8" title="1">*n = Node(net.JoinHostPort(v[0].(string), strconv.FormatInt(v[1].(int64), 10)))</span>
                }()
        default:<span class="cov8" title="1">
                err = fmt.Errorf("unsupported type: %T", iface)</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// From https://github.com/jackpal/Taipei-Torrent

// Copyright (c) 2010 Jack Palevich. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//    * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

package metainfo

// For more context on why these numbers, see http://wiki.vuze.com/w/Torrent_Piece_Size
const (
        minimumPieceLength   = 16 * 1024
        targetPieceCountLog2 = 10
        targetPieceCountMin  = 1 &lt;&lt; targetPieceCountLog2
)

// Target piece count should be &lt; targetPieceCountMax
const targetPieceCountMax = targetPieceCountMin &lt;&lt; 1

// Choose a good piecelength.
func ChoosePieceLength(totalLength int64) (pieceLength int64) <span class="cov8" title="1">{
        // Must be a power of 2.
        // Must be a multiple of 16KB
        // Prefer to provide around 1024..2048 pieces.
        pieceLength = minimumPieceLength
        pieces := totalLength / pieceLength
        for pieces &gt;= targetPieceCountMax </span><span class="cov8" title="1">{
                pieceLength &lt;&lt;= 1
                pieces &gt;&gt;= 1
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package metainfo

import (
        "iter"

        "tgragnato.it/magnetico/v2/types/infohash"
)

type Piece struct {
        Info  *Info
        index int
}

func (p Piece) Length() int64 <span class="cov8" title="1">{
        if p.Info.HasV2() </span><span class="cov0" title="0">{
                var offset int64
                pieceLength := p.Info.PieceLength
                lastFileEnd := int64(0)
                for fi := range p.Info.FileTree.upvertedFiles(pieceLength) </span><span class="cov0" title="0">{
                        fileStartPiece := int(offset / pieceLength)
                        if fileStartPiece &gt; p.index </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">lastFileEnd = offset + fi.Length
                        offset = (lastFileEnd + pieceLength - 1) / pieceLength * pieceLength</span>

                }
                <span class="cov0" title="0">ret := min(lastFileEnd-int64(p.index)*pieceLength, pieceLength)
                if ret &lt;= 0 </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov0" title="0">return ret</span>
        }
        <span class="cov8" title="1">return p.V1Length()</span>
}

func iterLast[T any](i iter.Seq[T]) (last T, ok bool) <span class="cov0" title="0">{
        for t := range i </span><span class="cov0" title="0">{
                last = t
                ok = true
        }</span>
        <span class="cov0" title="0">return</span>
}

func (p Piece) V1Length() int64 <span class="cov8" title="1">{
        i := p.index
        lastPiece := p.Info.NumPieces() - 1
        switch </span>{
        case 0 &lt;= i &amp;&amp; i &lt; lastPiece:<span class="cov8" title="1">
                return p.Info.PieceLength</span>
        case lastPiece &gt;= 0 &amp;&amp; i == lastPiece:<span class="cov0" title="0">
                lastFile, ok := iterLast(p.Info.UpvertedV1Files())
                if !ok </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov0" title="0">length := lastFile.TorrentOffset + lastFile.Length - int64(i)*p.Info.PieceLength
                if length &lt;= 0 || length &gt; p.Info.PieceLength </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov0" title="0">return length</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

func (p Piece) Offset() int64 <span class="cov8" title="1">{
        return int64(p.index) * p.Info.PieceLength
}</span>

func (p Piece) V1Hash() (ret infohash.T) <span class="cov8" title="1">{
        if !p.Info.HasV1() </span><span class="cov0" title="0">{
                return infohash.T{}
        }</span>
        <span class="cov8" title="1">copy(ret[:], p.Info.Pieces[p.index*infohash.Size:(p.index+1)*infohash.Size])
        return</span>
}

func (p Piece) Index() int <span class="cov0" title="0">{
        return p.index
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package metainfo

import (
        "crypto/sha1"
        "io"
)

func GeneratePieces(r io.Reader, pieceLength int64, b []byte) ([]byte, error) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                h := sha1.New()
                written, err := io.CopyN(h, r, pieceLength)
                if written &gt; 0 </span><span class="cov8" title="1">{
                        b = h.Sum(b)
                }</span>
                <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                        return b, nil
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return b, err
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package metainfo

import (
        "tgragnato.it/magnetico/v2/bencode"
)

type UrlList []string

var _ bencode.Unmarshaler = (*UrlList)(nil)

func (me *UrlList) UnmarshalBencode(b []byte) error <span class="cov8" title="1">{
        if len(b) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if b[0] == 'l' </span><span class="cov8" title="1">{
                var l []string
                err := bencode.Unmarshal(b, &amp;l)
                *me = l
                return err
        }</span>
        <span class="cov8" title="1">var s string
        err := bencode.Unmarshal(b, &amp;s)
        *me = []string{s}
        return err</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package opflags

import (
        "bufio"
        "bytes"
        "fmt"
        "io"
        "os"
        "regexp"
)

func (o *OpFlags) LoadCred() error <span class="cov8" title="1">{
        if o.Cred == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">file, err := os.Open(o.Cred)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error while opening file: %s", err.Error())
        }</span>

        <span class="cov8" title="1">reader := bufio.NewReader(file)
        for lineno := 1; true; lineno++ </span><span class="cov8" title="1">{
                line, err := reader.ReadBytes('\n')
                if err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov0" title="0">return fmt.Errorf("error while reading line %d: %s", lineno, err.Error())</span>
                }

                <span class="cov8" title="1">line = line[:len(line)-1] // strip '\n'

                /* The following regex checks if the line satisfies the following conditions:
                 *
                 * &lt;USERNAME&gt;:&lt;BCRYPT HASH&gt;
                 *
                 * where
                 *     &lt;USERNAME&gt; must start with a small-case a-z character, might contain non-consecutive
                 *   underscores in-between, and consists of small-case a-z characters and digits 0-9.
                 *
                 *     &lt;BCRYPT HASH&gt; is the output of the well-known bcrypt function.
                 */
                re := regexp.MustCompile(`^[a-z](?:_?[a-z0-9])*:\$2[aby]?\$\d{1,2}\$[./A-Za-z0-9]{53}$`)
                if !re.Match(line) </span><span class="cov8" title="1">{
                        return fmt.Errorf("on line %d: format should be: &lt;USERNAME&gt;:&lt;BCRYPT HASH&gt;, instead got: %s", lineno, line)
                }</span>

                <span class="cov0" title="0">tokens := bytes.Split(line, []byte(":"))
                o.Credentials[string(tokens[0])] = tokens[1]</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package opflags

import (
        "errors"
        "fmt"
        "net"
        "os"
        "path/filepath"
        "reflect"
)

type OpFlags struct {
        DatabaseURL  string `long:"database" description:"URL of the database." default:"postgres://magnetico:magnetico@localhost:5432/magnetico?sslmode=disable" yaml:"databaseURL"`
        PyroscopeURL string `long:"pyroscope" description:"URL of the Pyroscope server." default:"" yaml:"pyroscopeURL"`

        IndexerAddrs        []string `long:"indexer-addr" description:"Address(es) to be used by indexing DHT nodes." default:"0.0.0.0:0" yaml:"indexerAddrs"`
        IndexerMaxNeighbors uint     `long:"indexer-max-neighbors" description:"Maximum number of neighbors of an indexer." default:"5000" yaml:"indexerMaxNeighbors"`

        LeechDeadline uint `long:"leech-deadline" description:"Deadline for leeches in seconds." default:"600" yaml:"leechDeadline"`
        LeechMaxN     uint `long:"leech-max-n" description:"Maximum number of leeches." default:"1000" yaml:"leechMaxN"`
        MaxRPS        uint `long:"max-rps" description:"Maximum requests per second." default:"500" yaml:"maxRPS"`

        BootstrappingNodes []string `long:"bootstrap-node" description:"Host(s) to be used for bootstrapping." default:"dht.tgragnato.it:80" default:"dht.tgragnato.it:443" default:"dht.tgragnato.it:1337" default:"dht.tgragnato.it:6969" default:"dht.tgragnato.it:6881" default:"dht.tgragnato.it:25401" yaml:"bootstrappingNodes"`
        FilterNodesCIDRs   []string `long:"filter-nodes-cidrs" description:"List of CIDRs on which Magnetico can operate. Empty is open mode." default:"" yaml:"filterNodesCIDRs"`
        FilterNodesIpNets  []net.IPNet

        Addr        string `short:"a" long:"addr"        description:"Address (host:port) to serve on" default:"[::1]:8080" yaml:"addr"`
        Cred        string `short:"c" long:"credentials" description:"Path to the credentials file" default:"" yaml:"cred"`
        Credentials map[string][]byte
        Timeout     uint `short:"t" long:"timeout" description:"Timeout in seconds for the web interface and APIs." default:"600" yaml:"timeout"`

        RunDaemon bool `short:"d" long:"daemon" description:"Run the crawler without the web interface." yaml:"runDaemon"`
        RunWeb    bool `short:"w" long:"web"    description:"Run the web interface without the crawler." yaml:"runWeb"`

        Export string `short:"e" long:"export" description:"Export the database to the path." default:"" yaml:"export"`
        Import string `short:"i" long:"import" description:"Import the database from the path." default:"" yaml:"import"`

        ConfigFilePath string `long:"config-file-path" description:"Configuration YAML file path. If not filled in, it will default to disabled." default:""`
}

func (o *OpFlags) check() error <span class="cov8" title="1">{
        if !o.RunDaemon &amp;&amp; !o.RunWeb </span><span class="cov8" title="1">{
                o.RunDaemon = true
                o.RunWeb = true
        }</span>

        <span class="cov8" title="1">execName := filepath.Base(os.Args[0])
        switch execName </span>{
        case "magneticod":<span class="cov0" title="0">
                o.RunDaemon = true
                o.RunWeb = false</span>
        case "magneticow":<span class="cov0" title="0">
                o.RunDaemon = false
                o.RunWeb = true</span>
        }

        <span class="cov8" title="1">if o.RunWeb </span><span class="cov8" title="1">{
                o.Credentials = make(map[string][]byte)
                if err := o.LoadCred(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if o.RunDaemon </span><span class="cov8" title="1">{
                if err := o.checkAddrs(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">if o.LeechMaxN &gt; 1000 </span><span class="cov0" title="0">{
                        fmt.Println(
                                "Beware that on many systems max # of file descriptors per process is limited to 1024. " +
                                        "Setting maximum number of leeches greater than 1k might cause \"too many open files\" errors!",
                        )
                }</span>

                <span class="cov8" title="1">o.FilterNodesIpNets = []net.IPNet{}
                for _, cidr := range o.FilterNodesCIDRs </span><span class="cov8" title="1">{
                        if cidr == "" </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if _, ipnet, err := net.ParseCIDR(cidr); err == nil </span><span class="cov8" title="1">{
                                o.FilterNodesIpNets = append(o.FilterNodesIpNets, *ipnet)
                        }</span> else<span class="cov8" title="1"> {
                                return fmt.Errorf("error while parsing CIDR %s: %s", cidr, err.Error())
                        }</span>
                }
                <span class="cov8" title="1">if len(o.FilterNodesIpNets) != 0 &amp;&amp; reflect.DeepEqual(o.BootstrappingNodes, []string{"dht.tgragnato.it:80", "dht.tgragnato.it:443", "dht.tgragnato.it:1337", "dht.tgragnato.it:6969", "dht.tgragnato.it:6881", "dht.tgragnato.it:25401"}) </span><span class="cov8" title="1">{
                        return fmt.Errorf("you should specify your own internal bootstrapping nodes in filter mode")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (o *OpFlags) checkAddrs() error <span class="cov8" title="1">{
        if len(o.IndexerAddrs) == 0 || len(o.IndexerAddrs) == 1 &amp;&amp; o.IndexerAddrs[0] == "" </span><span class="cov8" title="1">{
                return errors.New("IndexerAddrs cannot be empty")
        }</span>

        <span class="cov8" title="1">for _, addr := range o.IndexerAddrs </span><span class="cov8" title="1">{
                // We are using ResolveUDPAddr but it works equally well for checking TCPAddr(esses) as
                // well.
                _, err := net.ResolveUDPAddr("udp", addr)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package opflags

import (
        "os"

        "github.com/goccy/go-yaml"
        "github.com/jessevdk/go-flags"
)

func (o *OpFlags) Parse() (err error) <span class="cov0" title="0">{
        parser := flags.NewParser(o, flags.Default)
        _, err = parser.Parse()
        if err != nil </span><span class="cov0" title="0">{
                if flagsErr, ok := err.(*flags.Error); ok &amp;&amp; flagsErr.Type == flags.ErrHelp </span><span class="cov0" title="0">{
                        os.Exit(0)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">err = o.parseYaml()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return o.check()</span>
}

func (o *OpFlags) parseYaml() error <span class="cov8" title="1">{
        if o.ConfigFilePath == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(o.ConfigFilePath)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return yaml.Unmarshal(data, o)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package stats

import (
        "net/http"
        "sync"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/collectors"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
        instance *Stats
        once     sync.Once
)

const namespace = "magnetico"

// GetStats returns a singleton instance of Stats
func GetInstance() *Stats <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                instance = &amp;Stats{
                        bootstrap: prometheus.NewCounter(prometheus.CounterOpts{
                                Namespace: namespace,
                                Name:      "bootstrap",
                                Help:      "Number of times the bootstrap process has been triggered",
                        }),
                        writeError: prometheus.NewCounter(prometheus.CounterOpts{
                                Namespace: namespace,
                                Name:      "write_error",
                                Help:      "Number of times there was an error writing a message to the UDP socket",
                        }),
                        readError: prometheus.NewCounter(prometheus.CounterOpts{
                                Namespace: namespace,
                                Name:      "read_error",
                                Help:      "Number of times there was an error reading a message from the UDP socket",
                        }),
                        rtClearing: prometheus.NewCounter(prometheus.CounterOpts{
                                Namespace: namespace,
                                Name:      "rt_clearing",
                                Help:      "Number of times the routing table has been cleared",
                        }),
                        nonUTF8: prometheus.NewCounter(prometheus.CounterOpts{
                                Namespace: namespace,
                                Name:      "non_utf8",
                                Help:      "Number of times a torrent has been ignored due to its name not being UTF-8 compliant",
                        }),
                        checkError: prometheus.NewCounter(prometheus.CounterOpts{
                                Namespace: namespace,
                                Name:      "check_error",
                                Help:      "Number of times there was an error checking whether a torrent exists",
                        }),
                        addError: prometheus.NewCounter(prometheus.CounterOpts{
                                Namespace: namespace,
                                Name:      "add_error",
                                Help:      "Number of times there was an error adding a torrent to the database",
                        }),
                        mseEncryption: prometheus.NewCounter(prometheus.CounterOpts{
                                Namespace: namespace,
                                Name:      "mse_encryption",
                                Help:      "Number of times a peer connection has been obfuscated with MSE",
                        }),
                        extensions: map[string]prometheus.Counter{},
                }
        }</span>)
        <span class="cov8" title="1">return instance</span>
}

// Create a new registry for Prometheus using the Go and Process collectors
func MakePrometheusHandler() http.HandlerFunc <span class="cov8" title="1">{

        registry := prometheus.NewRegistry()

        registry.MustRegister(
                collectors.NewGoCollector(),
                collectors.NewProcessCollector(collectors.ProcessCollectorOpts{
                        Namespace:    namespace,
                        ReportErrors: false,
                }),
                GetInstance(),
        )

        return promhttp.HandlerFor(registry, promhttp.HandlerOpts{}).ServeHTTP
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package stats

import (
        "errors"
        "os"
        "runtime"

        "github.com/grafana/pyroscope-go"
)

func InitPyroscope(serverAddress string) (*pyroscope.Profiler, error) <span class="cov8" title="1">{
        if serverAddress == "" </span><span class="cov8" title="1">{
                return nil, errors.New("pyroscope server address is required")
        }</span>

        <span class="cov8" title="1">runtime.SetMutexProfileFraction(5)
        runtime.SetBlockProfileRate(5)

        return pyroscope.Start(pyroscope.Config{
                ApplicationName: "magnetico.tgragnato.it",
                ServerAddress:   serverAddress,
                Logger:          nil,
                Tags:            map[string]string{"hostname": os.Getenv("HOSTNAME")},
                ProfileTypes: []pyroscope.ProfileType{
                        pyroscope.ProfileCPU,
                        pyroscope.ProfileAllocObjects,
                        pyroscope.ProfileAllocSpace,
                        pyroscope.ProfileInuseObjects,
                        pyroscope.ProfileInuseSpace,
                        pyroscope.ProfileGoroutines,
                        pyroscope.ProfileMutexCount,
                        pyroscope.ProfileMutexDuration,
                        pyroscope.ProfileBlockCount,
                        pyroscope.ProfileBlockDuration,
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package stats

import (
        "fmt"
        "regexp"
        "sync"

        "github.com/prometheus/client_golang/prometheus"
)

// Stats saves the metrics for each particular operation.
type Stats struct {
        // bootstrap represents the number of times the DHT has been bootstrapped.
        bootstrap prometheus.Counter
        // writeError represents the number of times there was an error writing a message to the UDP socket.
        writeError prometheus.Counter
        // readError represents the number of times there was an error reading a message from the UDP socket.
        readError prometheus.Counter
        // rtClearing represents the number of times the routing table has been cleared.
        rtClearing prometheus.Counter
        // nonUTF8 represents the number of times a torrent has been ignored due to its name not being UTF-8 compliant.
        nonUTF8 prometheus.Counter
        // checkError represents the number of times there was an error checking whether a torrent exists.
        checkError prometheus.Counter
        // addError represents the number of times there was an error adding a torrent to the database.
        addError prometheus.Counter
        // mseEncryption represents the number of times a peer connection has been obfuscated with mse.
        mseEncryption prometheus.Counter
        // extensions represents the number of times a peer connection has been negotiated with a given extension set.
        extensions map[string]prometheus.Counter

        sync.Mutex
}

func (s *Stats) Collect(ch chan&lt;- prometheus.Metric) <span class="cov8" title="1">{
        s.bootstrap.Collect(ch)
        s.writeError.Collect(ch)
        s.readError.Collect(ch)
        s.rtClearing.Collect(ch)
        s.nonUTF8.Collect(ch)
        s.checkError.Collect(ch)
        s.addError.Collect(ch)
        s.mseEncryption.Collect(ch)

        s.Lock()
        defer s.Unlock()
        for _, counter := range s.extensions </span><span class="cov8" title="1">{
                counter.Collect(ch)
        }</span>
}

func (s *Stats) Describe(descs chan&lt;- *prometheus.Desc) <span class="cov8" title="1">{
        prometheus.DescribeByCollect(s, descs)
}</span>

// IncBootstrap increments the bootstrap counter in the Stats struct.
func (s *Stats) IncBootstrap() <span class="cov8" title="1">{
        s.bootstrap.Inc()
}</span>

// IncUDPError increments the UDP error count in the Stats struct.
// If the 'write' parameter is true, it increments the writeError count.
// Otherwise, it increments the readError count.
func (s *Stats) IncUDPError(write bool) <span class="cov8" title="1">{
        if write </span><span class="cov8" title="1">{
                s.writeError.Inc()
        }</span> else<span class="cov8" title="1"> {
                s.readError.Inc()
        }</span>
}

// IncRtClearing increments the rtClearing field of the Stats struct.
func (s *Stats) IncRtClearing() <span class="cov8" title="1">{
        s.rtClearing.Inc()
}</span>

// IncNonUTF8 increments the nonUTF8 counter in the Stats struct.
func (s *Stats) IncNonUTF8() <span class="cov8" title="1">{
        s.nonUTF8.Inc()
}</span>

// IncDBError increments the error count for the database.
// If add is true, it increments the addError count.
// If add is false, it increments the checkError count.
func (s *Stats) IncDBError(add bool) <span class="cov8" title="1">{
        if add </span><span class="cov8" title="1">{
                s.addError.Inc()
        }</span> else<span class="cov8" title="1"> {
                s.checkError.Inc()
        }</span>
}

// IncLeech increments the leech statistics based on the provided 'peerExtensions'.
func (s *Stats) IncLeech(peerExtensions [8]byte) <span class="cov8" title="1">{
        s.mseEncryption.Inc()

        s.Lock()
        defer s.Unlock()

        extensionSet := string(fmt.Sprintf("%v", peerExtensions))
        extensionSet = regexp.MustCompile(`[^a-zA-Z0-9_:]`).ReplaceAllString(extensionSet, "_")

        if _, ok := s.extensions[extensionSet]; !ok </span><span class="cov8" title="1">{
                s.extensions[extensionSet] = prometheus.NewCounter(prometheus.CounterOpts{
                        Namespace: "magnetico",
                        Name:      "extension" + extensionSet,
                        Help:      "Number of times a peer connection has been negotiated with a given extension set",
                })
        }</span>

        <span class="cov8" title="1">s.extensions[extensionSet].Inc()</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package infohash_v2

import (
        "crypto/sha256"
        "encoding"
        "encoding/hex"
        "fmt"

        "github.com/multiformats/go-multihash"
        "tgragnato.it/magnetico/v2/types/infohash"
)

const Size = sha256.Size

// 32-byte SHA2-256 hash. See BEP 52.
type T [Size]byte

var _ fmt.Formatter = (*T)(nil)

func (t *T) Format(f fmt.State, c rune) <span class="cov8" title="1">{
        // TODO: I can't figure out a nice way to just override the 'x' rune, since it's meaningless
        // with the "default" 'v', or .String() already returning the hex.
        if _, err := f.Write([]byte(t.HexString())); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func (t *T) Bytes() []byte <span class="cov0" title="0">{
        return t[:]
}</span>

func (t *T) AsString() string <span class="cov0" title="0">{
        return string(t[:])
}</span>

func (t *T) String() string <span class="cov0" title="0">{
        return t.HexString()
}</span>

func (t *T) HexString() string <span class="cov8" title="1">{
        return fmt.Sprintf("%x", t[:])
}</span>

func (t *T) IsZero() bool <span class="cov8" title="1">{
        return *t == [Size]byte{}
}</span>

func (t *T) FromHexString(s string) (err error) <span class="cov8" title="1">{
        if len(s) != 2*Size </span><span class="cov8" title="1">{
                err = fmt.Errorf("hash hex string has bad length: %d", len(s))
                return
        }</span>
        <span class="cov8" title="1">n, err := hex.Decode(t[:], []byte(s))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if n != Size </span><span class="cov0" title="0">{
                panic(n)</span>
        }
        <span class="cov8" title="1">return</span>
}

// Truncates the hash to 20 bytes for use in auxiliary interfaces, like DHT and trackers.
func (t *T) ToShort() infohash.T <span class="cov8" title="1">{
        short := infohash.T{}
        copy(short[:], t[:infohash.Size])
        return short
}</span>

var (
        _ encoding.TextUnmarshaler = (*T)(nil)
        _ encoding.TextMarshaler   = T{}
)

func (t *T) UnmarshalText(b []byte) error <span class="cov8" title="1">{
        return t.FromHexString(string(b))
}</span>

func (t T) MarshalText() (text []byte, err error) <span class="cov8" title="1">{
        return []byte(t.HexString()), nil
}</span>

func FromHexString(s string) (h T) <span class="cov8" title="1">{
        err := h.FromHexString(s)
        if err != nil </span><span class="cov8" title="1">{
                return [Size]byte{}
        }</span>
        <span class="cov8" title="1">return</span>
}

func HashBytes(b []byte) (ret T) <span class="cov8" title="1">{
        hasher := sha256.New()
        hasher.Write(b)
        copy(ret[:], hasher.Sum(nil))
        return
}</span>

func ToMultihash(t T) multihash.Multihash <span class="cov8" title="1">{
        b, _ := multihash.Encode(t[:], multihash.SHA2_256)
        return b
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package infohash

import (
        "crypto/sha1"
        "crypto/sha256"
        "encoding"
        "encoding/hex"
        "fmt"
)

const Size = 20

// 20-byte SHA1 hash used for info and pieces.
type T [Size]byte

var _ fmt.Formatter = (*T)(nil)

func (t T) Format(f fmt.State, c rune) <span class="cov8" title="1">{
        // TODO: I can't figure out a nice way to just override the 'x' rune, since it's meaningless
        // with the "default" 'v', or .String() already returning the hex.
        _, err := f.Write([]byte(t.HexString()))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func (t T) Bytes() []byte <span class="cov0" title="0">{
        return t[:]
}</span>

func (t T) AsString() string <span class="cov0" title="0">{
        return string(t[:])
}</span>

func (t T) String() string <span class="cov8" title="1">{
        return t.HexString()
}</span>

func (t T) HexString() string <span class="cov8" title="1">{
        return fmt.Sprintf("%x", t[:])
}</span>

func (t *T) FromHexString(s string) (err error) <span class="cov8" title="1">{
        if len(s) != 2*Size </span><span class="cov8" title="1">{
                err = fmt.Errorf("hash hex string has bad length: %d", len(s))
                return
        }</span>
        <span class="cov8" title="1">n, err := hex.Decode(t[:], []byte(s))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if n != Size </span><span class="cov0" title="0">{
                panic(n)</span>
        }
        <span class="cov8" title="1">return</span>
}

func (t *T) IsZero() bool <span class="cov8" title="1">{
        return *t == T{}
}</span>

var (
        _ encoding.TextUnmarshaler = (*T)(nil)
        _ encoding.TextMarshaler   = T{}
)

func (t *T) UnmarshalText(b []byte) error <span class="cov8" title="1">{
        return t.FromHexString(string(b))
}</span>

func (t T) MarshalText() (text []byte, err error) <span class="cov8" title="1">{
        return []byte(t.HexString()), nil
}</span>

func FromHexString(s string) (h T) <span class="cov8" title="1">{
        if err := h.FromHexString(s); err != nil </span><span class="cov8" title="1">{
                h = T{}
        }</span>
        <span class="cov8" title="1">return</span>
}

func HashBytes(b []byte) (ret T) <span class="cov8" title="1">{
        hasher := sha1.New()
        hasher.Write(b)
        copy(ret[:], hasher.Sum(nil))
        return
}</span>

func HashBytesV2(b []byte) (ret T) <span class="cov8" title="1">{
        hasher := sha256.New()
        hasher.Write(b)
        copy(ret[:], hasher.Sum(nil))
        return
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
